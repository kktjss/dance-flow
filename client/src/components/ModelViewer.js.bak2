import React, { useRef, useState, useEffect, Suspense, useCallback } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera, useGLTF, Grid } from '@react-three/drei';
import { Box as MuiBox, CircularProgress, Button, IconButton, Slider, Typography, Tooltip, Dialog, DialogTitle, DialogContent, DialogActions, TextField, List, ListItem, ListItemText, ListItemSecondaryAction, Menu, MenuItem, Select, FormControl, InputLabel, Tabs, Tab } from '@mui/material';
import { PlayArrow, Pause, AddCircleOutline, Delete, Edit, DragIndicator, Save, FolderOpen, Upload, Close as CloseIcon } from '@mui/icons-material';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import ModelUploader from './ModelUploader';

// Model component for Xbot
const XbotModel = ({ currentTime, isPlaying, onTimeUpdate, onModelLoad, playerDuration, animationMarkers = [], activeAnimations = [], glbAnimationUrl = null, elementId = null, elementKeyframes = [] }) => {
    // We're not using the default Xbot model anymore
    const [customModel, setCustomModel] = useState(null);
    const [loadingError, setLoadingError] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [debugInfo, setDebugInfo] = useState({
        modelLoaded: false,
        animationsCount: 0,
        modelUrl: null,
        modelPosition: [0, 0, 0],
        modelScale: [1, 1, 1],
        error: null
    });

    const mixer = useRef(null);
    const lastTimeRef = useRef(null);
    const animationRef = useRef(null);
    const clock = useRef(new THREE.Clock());
    const modelDuration = useRef(0);
    const animationsRef = useRef([]);
    const activeActionsRef = useRef({});
    const [externalAnimations, setExternalAnimations] = useState({});
    const modelRef = useRef(null);

    // Handle WebGL context loss
    useEffect(() => {
        const handleContextLost = (event) => {
            event.preventDefault();
            console.warn('XbotModel: WebGL context was lost');

            // Stop any ongoing animations
            if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
                animationRef.current = null;
            }

            // Reset mixer
            mixer.current = null;

            // Set loading error
            setLoadingError('WebGL контекст был потерян. Пожалуйста, перезагрузите страницу.');
            setDebugInfo(prev => ({ ...prev, error: 'WebGL context lost' }));
        };

        const handleContextRestored = () => {
            console.log('XbotModel: WebGL context was restored');

            // Clear error
            setLoadingError(null);
            setDebugInfo(prev => ({ ...prev, error: null }));

            // Reload the model
            if (glbAnimationUrl) {
                console.log('XbotModel: Reloading model after context restore');
                // The model will be reloaded by the useEffect that watches glbAnimationUrl
            }
        };

        // Add event listeners
        window.addEventListener('webglcontextlost', handleContextLost);
        window.addEventListener('webglcontextrestored', handleContextRestored);

        return () => {
            // Remove event listeners
            window.removeEventListener('webglcontextlost', handleContextLost);
            window.removeEventListener('webglcontextrestored', handleContextRestored);
        };
    }, [glbAnimationUrl]);

    // Load custom GLB model if URL is provided
    useEffect(() => {
        if (glbAnimationUrl) {
            console.log('XbotModel: Loading custom GLB model from URL:', glbAnimationUrl);
            console.log('XbotModel: Element details:', {
                elementId: elementId || 'not provided',
                hasKeyframes: elementKeyframes && elementKeyframes.length > 0,
                keyframesCount: elementKeyframes ? elementKeyframes.length : 0
            });

            setIsLoading(true);
            setLoadingError(null);
            setDebugInfo(prev => ({
                ...prev,
                modelLoaded: false,
                modelUrl: glbAnimationUrl,
                error: null
            }));

            // Преобразование относительного URL в абсолютный, если необходимо
            let processedUrl = glbAnimationUrl;
            if (glbAnimationUrl.startsWith('/') && !glbAnimationUrl.startsWith('//')) {
                processedUrl = `${window.location.origin}${glbAnimationUrl}`;
            }

            console.log('XbotModel: Processed URL for loading:', processedUrl);
            console.log('XbotModel: Current origin:', window.location.origin);

            try {
                // Use GLTFLoader directly
                const loader = new GLTFLoader();

                // Добавляем обработчик для CORS-ошибок
                THREE.DefaultLoadingManager.onError = function (url) {
                    console.error('XbotModel: Error loading resource', url);
                    setLoadingError(`Ошибка загрузки ресурса: ${url}`);
                    setDebugInfo(prev => ({ ...prev, error: `Resource loading error: ${url}` }));
                };

                // Специальная обработка для blob URL
                if (processedUrl.startsWith('blob:')) {
                    console.log('XbotModel: Detected blob URL, using special handling for local file');
                }

                console.log('XbotModel: Starting to load model from:', processedUrl);

                // Устанавливаем crossOrigin для загрузчика
                THREE.DefaultLoadingManager.crossOrigin = 'anonymous';

                // Add a timeout to detect if the load is taking too long
                const loadTimeout = setTimeout(() => {
                    console.warn('XbotModel: Model loading is taking longer than expected');
                    setDebugInfo(prev => ({ ...prev, error: 'Loading timeout - taking longer than expected' }));
                }, 5000);

                loader.load(
                    processedUrl,
                    (gltf) => {
                        clearTimeout(loadTimeout);
                        console.log('XbotModel: Custom model loaded successfully with animations:', gltf.animations);
                        console.log('XbotModel: Model scene:', gltf.scene);

                        // Apply default transformations to the model
                        gltf.scene.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                console.log('XbotModel: Applied shadows to mesh:', child.name);
                            }
                        });

                        // Center the model
                        const box = new THREE.Box3().setFromObject(gltf.scene);
                        const center = box.getCenter(new THREE.Vector3());
                        gltf.scene.position.x = -center.x;
                        gltf.scene.position.y = -center.y;
                        gltf.scene.position.z = -center.z;

                        // Apply a default scale if the model is too large or too small
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        let scale = 1;
                        if (maxDim > 10) {
                            scale = 5 / maxDim;
                            gltf.scene.scale.set(scale, scale, scale);
                            console.log('XbotModel: Model was too large, scaled down by factor:', scale);
                        } else if (maxDim < 1) {
                            scale = 2 / maxDim;
                            gltf.scene.scale.set(scale, scale, scale);
                            console.log('XbotModel: Model was too small, scaled up by factor:', scale);
                        }

                        // Store model position and scale for debugging
                        setDebugInfo(prev => ({
                            ...prev,
                            modelLoaded: true,
                            modelPosition: [
                                gltf.scene.position.x,
                                gltf.scene.position.y,
                                gltf.scene.position.z
                            ],
                            modelScale: [scale, scale, scale],
                            animationsCount: gltf.animations ? gltf.animations.length : 0
                        }));

                        // Store a reference to the model
                        modelRef.current = gltf.scene;

                        setCustomModel({ scene: gltf.scene, animations: gltf.animations });

                        // Pass animations to parent if available
                        if (gltf.animations && gltf.animations.length > 0) {
                            console.log('XbotModel: Passing animations to parent component');
                            onModelLoad(gltf.animations);
                        } else {
                            console.warn('XbotModel: Model loaded but no animations found');
                            // Create a default animation if none exists
                            const defaultAnimation = new THREE.AnimationClip('Default', 5, []);
                            onModelLoad([defaultAnimation]);
                        }

                        setIsLoading(false);
                    },
                    (xhr) => {
                        const progress = Math.round(xhr.loaded / xhr.total * 100);
                        console.log(`XbotModel: Loading progress: ${progress}%`);
                        setDebugInfo(prev => ({ ...prev, loadingProgress: progress }));
                    },
                    (error) => {
                        clearTimeout(loadTimeout);
                        console.error('XbotModel: Error loading custom GLB model:', error);
                        console.error('XbotModel: Error details:', error.message);

                        // Set error message
                        setLoadingError(`Ошибка загрузки модели: ${error.message}`);
                        setDebugInfo(prev => ({ ...prev, error: `Model loading error: ${error.message}` }));
                        setIsLoading(false);
                    }
                );
            } catch (error) {
                console.error('XbotModel: Error in loadModel function:', error);
                console.error('XbotModel: Error stack:', error.stack);
                setLoadingError(`Ошибка загрузки модели: ${error.message}`);
                setDebugInfo(prev => ({ ...prev, error: `Exception: ${error.message}` }));
                setIsLoading(false);
            }
        } else {
            console.log('XbotModel: No GLB URL provided, skipping model load');
            setCustomModel(null);
            setLoadingError(null);
            setIsLoading(false);
            setDebugInfo(prev => ({
                ...prev,
                modelLoaded: false,
                modelUrl: null,
                error: 'No GLB URL provided'
            }));
        }

        // Cleanup function
        return () => {
            // Reset error handler
            THREE.DefaultLoadingManager.onError = null;
            THREE.DefaultLoadingManager.crossOrigin = 'anonymous';
        };
    }, [glbAnimationUrl, onModelLoad, elementId, elementKeyframes]);

    // Initialize animation mixer
    useEffect(() => {
        if (customModel && customModel.animations && customModel.animations.length > 0) {
            console.log('XbotModel: Model loaded successfully with animations:', customModel.animations);
            console.log('XbotModel: Animation names:', customModel.animations.map(anim => anim.name));

            // Create a new mixer for the current model
            mixer.current = new THREE.AnimationMixer(customModel.scene);
            animationsRef.current = customModel.animations;

            // Store original model animation duration from the first animation
            modelDuration.current = customModel.animations[0].duration;
            console.log('XbotModel: Model duration:', modelDuration.current);

            // Pass animations to parent
            onModelLoad(customModel.animations);

            setDebugInfo(prev => ({
                ...prev,
                animationsCount: customModel.animations.length,
                animationNames: customModel.animations.map(anim => anim.name).join(', ')
            }));
        } else if (customModel) {
            console.warn('XbotModel: Model loaded but no animations found:', customModel);
            setDebugInfo(prev => ({
                ...prev,
                animationsCount: 0,
                animationNames: 'No animations found'
            }));
        }
    }, [customModel, onModelLoad]);

    // Load external animation
    const loadExternalAnimation = useCallback(async (url) => {
        if (!url || externalAnimations[url]) return;

        try {
            console.log('XbotModel: Loading external animation from URL:', url);

            // Use GLTFLoader directly
            const loader = new GLTFLoader();

            // Специальная обработка для blob URL
            if (url.startsWith('blob:')) {
                console.log('XbotModel: Detected blob URL for animation, using special handling for local file');
            }

            // Устанавливаем crossOrigin для загрузчика
            THREE.DefaultLoadingManager.crossOrigin = 'anonymous';

            loader.load(
                url,
                (gltf) => {
                    const animations = gltf.animations;

                    if (animations && animations.length > 0) {
                        console.log(`Loaded ${animations.length} animations from ${url}`);

                        // Store animations with their URL as key
                        setExternalAnimations(prev => ({
                            ...prev,
                            [url]: animations
                        }));

                        // Add to available animations
                        const newAnimations = [...animationsRef.current];
                        animations.forEach(anim => {
                            // Set a custom property to identify external animations
                            anim.isExternal = true;
                            anim.sourceUrl = url;
                            newAnimations.push(anim);
                        });

                        animationsRef.current = newAnimations;

                        // Notify parent about new animations
                        onModelLoad(newAnimations);
                    }
                },
                (xhr) => {
                    console.log(`Loading animation progress: ${Math.round(xhr.loaded / xhr.total * 100)}%`);
                },
                (error) => {
                    console.error(`Error loading animation from ${url}:`, error);
                }
            );
        } catch (error) {
            console.error(`Error in loadExternalAnimation for ${url}:`, error);
        }
    }, [externalAnimations, onModelLoad]);

    // Update active animations when the activeAnimations prop changes
    useEffect(() => {
        if (!mixer.current || !customModel) return;

        // Load any external animations first
        activeAnimations.forEach(anim => {
            if (anim.url) {
                loadExternalAnimation(anim.url);
            }
        });

        // Stop all current actions
        Object.values(activeActionsRef.current).forEach(action => {
            if (action) action.stop();
        });

        // Reset active actions
        activeActionsRef.current = {};

        // Create new actions for each active animation
        activeAnimations.forEach(anim => {
            // Find the animation by name, index, or from external source
            let animation;

            if (anim.url && externalAnimations[anim.url]) {
                // Find animation in external animations
                const externalAnims = externalAnimations[anim.url];
                animation = externalAnims[anim.externalIndex || 0];
            } else {
                // Find in default animations
                animation = typeof anim.index === 'number'
                    ? animationsRef.current[anim.index]
                    : animationsRef.current.find(a => a.name === anim.name);
            }

            if (animation) {
                const action = mixer.current.clipAction(animation);
                action.setLoop(THREE.LoopRepeat);
                action.clampWhenFinished = true;
                action.play();

                // Store the action reference
                activeActionsRef.current[anim.id] = action;

                // Set time scale if specified
                if (typeof anim.timeScale === 'number') {
                    action.timeScale = anim.timeScale;
                }

                // Set weight if specified (for blending)
                if (typeof anim.weight === 'number') {
                    action.weight = anim.weight;
                }

                console.log('XbotModel: Added animation action:', {
                    id: anim.id,
                    name: animation.name,
                    duration: animation.duration,
                    timeScale: action.timeScale,
                    weight: action.weight
                });
            } else {
                console.warn('XbotModel: Could not find animation for:', anim);
            }
        });

        // Force update mixer to apply changes
        if (mixer.current) {
            mixer.current.update(0);
        }
    }, [activeAnimations, externalAnimations, loadExternalAnimation, customModel]);

    // Find the current animation segment based on markers
    const getCurrentAnimationSegment = useCallback(() => {
        if (!animationMarkers || animationMarkers.length === 0) {
            return { start: 0, end: modelDuration.current, modelStart: 0, modelEnd: modelDuration.current };
        }

        // Sort markers by time
        const sortedMarkers = [...animationMarkers].sort((a, b) => a.time - b.time);

        // Find the current segment
        for (let i = 0; i < sortedMarkers.length - 1; i++) {
            if (currentTime >= sortedMarkers[i].time && currentTime < sortedMarkers[i + 1].time) {
                return {
                    start: sortedMarkers[i].time,
                    end: sortedMarkers[i + 1].time,
                    modelStart: sortedMarkers[i].modelTime,
                    modelEnd: sortedMarkers[i + 1].modelTime
                };
            }
        }

        // If we're past the last marker, loop back to the first segment
        if (currentTime >= sortedMarkers[sortedMarkers.length - 1].time) {
            return {
                start: sortedMarkers[sortedMarkers.length - 1].time,
                end: playerDuration,
                modelStart: sortedMarkers[sortedMarkers.length - 1].modelTime,
                modelEnd: modelDuration.current
            };
        }

        // Default to the first segment
        return {
            start: 0,
            end: sortedMarkers[0]?.time || playerDuration,
            modelStart: 0,
            modelEnd: sortedMarkers[0]?.modelTime || modelDuration.current
        };
    }, [currentTime, animationMarkers, playerDuration]);

    // Find the active animation at the current time
    const getActiveAnimationAtTime = useCallback(() => {
        if (!activeAnimations || activeAnimations.length === 0) {
            return [];
        }

        // Find animations that are active at the current time
        return activeAnimations.filter(anim =>
            currentTime >= anim.start && currentTime <= anim.end
        );
    }, [currentTime, activeAnimations]);

    // Update animation time when scrubbing
    useEffect(() => {
        if (mixer.current && !isPlaying) {
            // Get active animations at current time
            const activeAnimsAtTime = getActiveAnimationAtTime();

            // If no animations are active at this time, use the default behavior with markers
            if (activeAnimsAtTime.length === 0) {
                let scaledTime;

                if (animationMarkers && animationMarkers.length > 0) {
                    // Use markers for precise animation segment mapping
                    const segment = getCurrentAnimationSegment();
                    const segmentProgress = (currentTime - segment.start) / (segment.end - segment.start);
                    scaledTime = segment.modelStart + segmentProgress * (segment.modelEnd - segment.modelStart);
                } else {
                    // Default scaling when no markers are present
                    scaledTime = playerDuration
                        ? (currentTime / playerDuration) * modelDuration.current
                        : currentTime;
                }

                mixer.current.time = scaledTime;

                // Force update mixer to apply changes
                mixer.current.update(0);
                return;
            }

            // For each active animation, set its time based on the current player time
            activeAnimsAtTime.forEach(anim => {
                const action = activeActionsRef.current[anim.id];
                if (action) {
                    // Calculate the progress within this animation's time range
                    const animProgress = (currentTime - anim.start) / (anim.end - anim.start);

                    // Calculate the model time based on the animation's duration
                    const animation = animationsRef.current[anim.index];
                    if (animation) {
                        const animDuration = animation.duration;
                        const modelTime = animProgress * animDuration;

                        // Set the action time directly
                        action.time = modelTime;

                        // Force update mixer to apply changes
                        mixer.current.update(0);
                    }
                }
            });
        }
    }, [currentTime, isPlaying, playerDuration, animationMarkers, getCurrentAnimationSegment, getActiveAnimationAtTime]);

    // Animation loop with precise timing
    const animate = useCallback((timestamp) => {
        if (!lastTimeRef.current) {
            lastTimeRef.current = timestamp;
        }

        const elapsed = timestamp - lastTimeRef.current;

        if (mixer.current && isPlaying) {
            const delta = clock.current.getDelta();
            mixer.current.update(delta);

            // Update time approximately 30 times per second
            if (elapsed > 33) { // ~30fps
                // Get active animations at current time
                const activeAnimsAtTime = getActiveAnimationAtTime();

                // Update player time based on animation progress
                let playerTime = currentTime + delta;

                // If we have active animations at this time, check if we need to adjust the player time
                if (activeAnimsAtTime.length > 0) {
                    // Check if we've reached the end of any animation segment
                    const endingAnims = activeAnimsAtTime.filter(anim => playerTime >= anim.end);
                    if (endingAnims.length > 0) {
                        // If we've reached the end of all active animations, loop back or stop
                        if (endingAnims.length === activeAnimsAtTime.length) {
                            // If we've reached the end of the player duration, loop back to start
                            if (playerTime >= playerDuration) {
                                playerTime = 0;
                                mixer.current.time = 0;
                            }
                        }
                    }
                } else {
                    // Default behavior when no animations are active at this time
                    if (animationMarkers && animationMarkers.length > 0) {
                        // Use markers for precise animation segment mapping
                        const segment = getCurrentAnimationSegment();
                        const modelTime = mixer.current.time;
                        const segmentProgress = (modelTime - segment.modelStart) / (segment.modelEnd - segment.modelStart);
                        playerTime = segment.start + segmentProgress * (segment.end - segment.start);

                        // Check if we've reached the end of the segment
                        if (playerTime >= segment.end) {
                            playerTime = segment.end;
                        }
                    } else {
                        // Default scaling when no markers are present
                        const modelTime = mixer.current.time;
                        playerTime = playerDuration
                            ? (modelTime / modelDuration.current) * playerDuration
                            : modelTime;
                    }

                    // Check if we've reached the end of the player duration
                    if (playerTime >= playerDuration) {
                        playerTime = 0;
                        mixer.current.time = 0;
                    }
                }

                onTimeUpdate(playerTime);
                lastTimeRef.current = timestamp;
            }
        }

        if (isPlaying) {
            animationRef.current = requestAnimationFrame(animate);
        }
    }, [isPlaying, onTimeUpdate, playerDuration, animationMarkers, getCurrentAnimationSegment, currentTime, getActiveAnimationAtTime]);

    // Setup and cleanup animation frame
    useEffect(() => {
        if (isPlaying) {
            clock.current.start();
            lastTimeRef.current = null;
            animationRef.current = requestAnimationFrame(animate);
        } else {
            clock.current.stop();
        }

        return () => {
            if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
                animationRef.current = null;
            }
        };
    }, [isPlaying, animate]);

    // Handle animation end
    useEffect(() => {
        if (mixer.current && playerDuration && currentTime >= playerDuration) {
            onTimeUpdate(0);
            mixer.current.time = 0;
        }
    }, [currentTime, playerDuration, onTimeUpdate]);

    return (
        <>
            {isLoading && (
                <>
                    <mesh position={[0, 0, 0]}>
                        <sphereGeometry args={[0.5, 16, 16]} />
                        <meshStandardMaterial color="gray" wireframe />
                    </mesh>
                    <mesh position={[0, 1, 0]}>
                        <boxGeometry args={[1, 0.1, 0.1]} />
                        <meshStandardMaterial color="white" />
                    </mesh>
                </>
            )}

            {loadingError && (
                <>
                    <mesh position={[0, 0, 0]}>
                        <boxGeometry args={[1, 1, 1]} />
                        <meshStandardMaterial color="red" />
                    </mesh>
                    <mesh position={[0, 1.5, 0]}>
                        <boxGeometry args={[0.1, 0.1, 0.1]} />
                        <meshStandardMaterial color="yellow" />
                    </mesh>
                </>
            )}

            {!isLoading && !loadingError && customModel && (
                <>
                    {/* Render the custom model */}
                    <primitive
                        object={customModel.scene}
                        scale={[1.0, 1.0, 1.0]}
                        position={[0, 0, 0]}
                        rotation={[0, 0, 0]}
                    />

                    {/* Debug axes to show orientation */}
                    <axesHelper args={[5]} />

                    {/* Debug grid to show ground plane */}
                    <gridHelper args={[10, 10, 0x888888, 0x444444]} />
                </>
            )}

            {/* Debug info overlay - always visible */}
            <mesh position={[0, -2, 0]}>
                <boxGeometry args={[0.2, 0.2, 0.2]} />
                <meshStandardMaterial color={debugInfo.modelLoaded ? "green" : "red"} />
            </mesh>
        </>
    );
};

// Custom Slider with markers
const MarkedSlider = ({ value, min, max, onChange, markers = [], disabled, onMarkerAdd, onMarkerEdit, onMarkerDelete }) => {
    const getMarkerPosition = (time) => ((time - min) / (max - min)) * 100;

    return (
        <MuiBox sx={{ position: 'relative', width: '100%', mx: 2 }}>
            <Slider
                value={value}
                min={min}
                max={max}
                onChange={onChange}
                step={0.001}
                disabled={disabled}
                sx={{ zIndex: 1 }}
            />
            {markers.map((marker, index) => (
                <Tooltip
                    key={index}
                    title={`${marker.label || `Маркер ${index + 1}`} (${marker.time.toFixed(2)}с)`}
                    arrow
                >
                    <MuiBox
                        onClick={(e) => {
                            e.stopPropagation();
                            onMarkerEdit(index);
                        }}
                        onContextMenu={(e) => {
                            e.preventDefault();
                            onMarkerDelete(index);
                        }}
                        sx={{
                            position: 'absolute',
                            left: `${getMarkerPosition(marker.time)}%`,
                            top: '50%',
                            transform: 'translate(-50%, -50%)',
                            width: '12px',
                            height: '12px',
                            backgroundColor: marker.color || '#f44336',
                            borderRadius: '50%',
                            border: '2px solid white',
                            zIndex: 2,
                            cursor: 'pointer',
                            '&:hover': {
                                transform: 'translate(-50%, -50%) scale(1.2)',
                                boxShadow: '0 0 5px rgba(0,0,0,0.3)'
                            }
                        }}
                    />
                </Tooltip>
            ))}
            <IconButton
                size="small"
                onClick={onMarkerAdd}
                sx={{
                    position: 'absolute',
                    right: '-30px',
                    top: '50%',
                    transform: 'translateY(-50%)',
                    zIndex: 2,
                    backgroundColor: 'rgba(0,0,0,0.1)',
                    '&:hover': {
                        backgroundColor: 'rgba(0,0,0,0.2)'
                    }
                }}
            >
                <AddCircleOutline fontSize="small" />
            </IconButton>
        </MuiBox>
    );
};

// Animation Manager Component
const AnimationManager = ({ animations = [], activeAnimations = [], onAnimationsChange }) => {
    const [anchorEl, setAnchorEl] = useState(null);
    const [selectedAnimIndex, setSelectedAnimIndex] = useState(null);
    const [animationDialogOpen, setAnimationDialogOpen] = useState(false);
    const [currentAnimation, setCurrentAnimation] = useState(null);

    // Animation dialog form state
    const [animName, setAnimName] = useState('');
    const [animIndex, setAnimIndex] = useState(0);
    const [animStart, setAnimStart] = useState(0);
    const [animEnd, setAnimEnd] = useState(10);
    const [animWeight, setAnimWeight] = useState(1);
    const [animTimeScale, setAnimTimeScale] = useState(1);
    const [animExternalIndex, setAnimExternalIndex] = useState(0);

    // Generate a unique ID for new animations
    const generateUniqueId = () => {
        return 'anim_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    };

    // Open context menu for an animation
    const handleAnimationMenuOpen = (event, index) => {
        event.preventDefault();
        event.stopPropagation();
        setAnchorEl(event.currentTarget);
        setSelectedAnimIndex(index);
    };

    // Close context menu
    const handleAnimationMenuClose = () => {
        setAnchorEl(null);
        setSelectedAnimIndex(null);
    };

    // Open dialog to add a new animation
    const handleAddAnimation = () => {
        setCurrentAnimation(null);

        // Set default values for a new animation
        setAnimName('');
        setAnimIndex(0);
        setAnimStart(0);
        setAnimEnd(10);
        setAnimWeight(1);
        setAnimTimeScale(1);
        setAnimExternalIndex(0);

        setAnimationDialogOpen(true);
    };

    // Open dialog to edit an existing animation
    const handleEditAnimation = () => {
        const anim = activeAnimations[selectedAnimIndex];

        setCurrentAnimation(anim);
        setAnimName(anim.name || '');
        setAnimIndex(anim.index || 0);
        setAnimStart(anim.start || 0);
        setAnimEnd(anim.end || 10);
        setAnimWeight(anim.weight || 1);
        setAnimTimeScale(anim.timeScale || 1);
        setAnimExternalIndex(anim.externalIndex || 0);

        setAnimationDialogOpen(true);
        handleAnimationMenuClose();
    };

    // Delete an animation
    const handleDeleteAnimation = () => {
        const newAnimations = [...activeAnimations];
        newAnimations.splice(selectedAnimIndex, 1);
        onAnimationsChange(newAnimations);
        handleAnimationMenuClose();
    };

    // Save animation changes
    const handleSaveAnimation = () => {
        if (currentAnimation) {
            // Update existing animation
            const newAnimations = activeAnimations.map(anim =>
                anim.id === currentAnimation.id
                    ? {
                        ...anim,
                        name: animName,
                        index: animIndex,
                        start: animStart,
                        end: animEnd,
                        weight: animWeight,
                        timeScale: animTimeScale,
                        externalIndex: animExternalIndex
                    }
                    : anim
            );
            onAnimationsChange(newAnimations);
        } else {
            // Add new animation
            const newAnimation = {
                id: generateUniqueId(),
                name: animName,
                index: animIndex,
                start: animStart,
                end: animEnd,
                weight: animWeight,
                timeScale: animTimeScale,
                externalIndex: animExternalIndex
            };
            onAnimationsChange([...activeAnimations, newAnimation]);
        }

        setAnimationDialogOpen(false);
    };

    return (
        <>
            <MuiBox sx={{ width: '100%', mt: 2, color: 'white' }}>
                <Typography variant="subtitle1" gutterBottom>
                    Анимации ({activeAnimations.length})
                    <IconButton
                        size="small"
                        onClick={handleAddAnimation}
                        sx={{ ml: 1, color: 'white' }}
                    >
                        <AddCircleOutline />
                    </IconButton>
                </Typography>

                {activeAnimations.length === 0 ? (
                    <Typography variant="body2" color="text.secondary">
                        Нет активных анимаций. Нажмите + чтобы добавить анимацию.
                    </Typography>
                ) : (
                    <List dense sx={{ bgcolor: 'rgba(0,0,0,0.3)', borderRadius: 1 }}>
                        {activeAnimations.map((anim, index) => (
                            <ListItem
                                key={anim.id}
                                sx={{
                                    borderBottom: index < activeAnimations.length - 1 ? '1px solid rgba(255,255,255,0.1)' : 'none',
                                    '&:hover': { bgcolor: 'rgba(255,255,255,0.05)' }
                                }}
                                secondaryAction={
                                    <IconButton
                                        edge="end"
                                        size="small"
                                        onClick={(e) => handleAnimationMenuOpen(e, index)}
                                        sx={{ color: 'white' }}
                                    >
                                        <Edit fontSize="small" />
                                    </IconButton>
                                }
                            >
                                <DragIndicator sx={{ mr: 1, opacity: 0.5, fontSize: '1rem' }} />
                                <ListItemText
                                    primary={anim.name || `Анимация ${animations[anim.index]?.name || anim.index}`}
                                    secondary={
                                        <>
                                            {`${anim.start}с - ${anim.end}с (скорость: ${anim.timeScale}x)`}
                                        </>
                                    }
                                    primaryTypographyProps={{ variant: 'body2' }}
                                    secondaryTypographyProps={{ variant: 'caption' }}
                                />
                            </ListItem>
                        ))}
                    </List>
                )}
            </MuiBox>

            {/* Animation Context Menu */}
            <Menu
                anchorEl={anchorEl}
                open={Boolean(anchorEl)}
                onClose={handleAnimationMenuClose}
            >
                <MenuItem onClick={handleEditAnimation}>
                    <Edit fontSize="small" sx={{ mr: 1 }} /> Редактировать
                </MenuItem>
                <MenuItem onClick={handleDeleteAnimation}>
                    <Delete fontSize="small" sx={{ mr: 1 }} /> Удалить
                </MenuItem>
            </Menu>

            {/* Animation Edit Dialog */}
            <Dialog open={animationDialogOpen} onClose={() => setAnimationDialogOpen(false)}>
                <DialogTitle>
                    {currentAnimation ? 'Редактировать анимацию' : 'Добавить анимацию'}
                </DialogTitle>
                <DialogContent>
                    <TextField
                        margin="dense"
                        label="Название"
                        type="text"
                        fullWidth
                        value={animName}
                        onChange={(e) => setAnimName(e.target.value)}
                        sx={{ mb: 2 }}
                    />

                    {/* Выбор анимации */}
                    <FormControl fullWidth margin="dense" sx={{ mb: 2 }}>
                        <InputLabel>Анимация</InputLabel>
                        <Select
                            value={animIndex}
                            onChange={(e) => setAnimIndex(Number(e.target.value))}
                            label="Анимация"
                        >
                            {animations.map((anim, index) => (
                                <MenuItem key={index} value={index}>
                                    {anim.name || `Анимация ${index + 1}`}
                                </MenuItem>
                            ))}
                        </Select>
                    </FormControl>

                    <TextField
                        margin="dense"
                        label="Начало (секунды)"
                        type="number"
                        fullWidth
                        value={animStart}
                        onChange={(e) => setAnimStart(Number(e.target.value))}
                        inputProps={{ step: 0.1, min: 0 }}
                        sx={{ mb: 2 }}
                    />

                    <TextField
                        margin="dense"
                        label="Конец (секунды)"
                        type="number"
                        fullWidth
                        value={animEnd}
                        onChange={(e) => setAnimEnd(Number(e.target.value))}
                        inputProps={{ step: 0.1, min: animStart }}
                        sx={{ mb: 2 }}
                    />

                    <TextField
                        margin="dense"
                        label="Вес (для смешивания)"
                        type="number"
                        fullWidth
                        value={animWeight}
                        onChange={(e) => setAnimWeight(Number(e.target.value))}
                        inputProps={{ step: 0.1, min: 0, max: 1 }}
                        sx={{ mb: 2 }}
                        helperText="От 0 до 1, используется для смешивания анимаций"
                    />

                    <TextField
                        margin="dense"
                        label="Скорость воспроизведения"
                        type="number"
                        fullWidth
                        value={animTimeScale}
                        onChange={(e) => setAnimTimeScale(Number(e.target.value))}
                        inputProps={{ step: 0.1, min: 0.1 }}
                        helperText="1 = нормальная скорость, 0.5 = замедленно, 2 = ускоренно"
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setAnimationDialogOpen(false)}>Отмена</Button>
                    <Button onClick={handleSaveAnimation} color="primary">Сохранить</Button>
                </DialogActions>
            </Dialog>
        </>
    );
};

// Animation Timeline Component
const AnimationTimeline = ({ animations = [], activeAnimations = [], duration = 60, currentTime = 0, onAnimationsChange }) => {
    const [draggingAnimation, setDraggingAnimation] = useState(null);
    const [draggingEdge, setDraggingEdge] = useState(null); // 'start' or 'end'
    const [dragStartX, setDragStartX] = useState(0);
    const [dragStartTime, setDragStartTime] = useState(0);
    const timelineRef = useRef(null);

    // Calculate position on timeline from time
    const getPositionFromTime = (time) => {
        return (time / duration) * 100;
    };

    // Calculate time from position on timeline
    const getTimeFromPosition = (position, width) => {
        const percent = position / width;
        return Math.max(0, Math.min(duration, percent * duration));
    };

    // Start dragging an animation
    const handleDragStart = (e, animId, edge = null) => {
        e.preventDefault();
        e.stopPropagation();

        const timelineRect = timelineRef.current.getBoundingClientRect();
        const mouseX = e.clientX - timelineRect.left;

        setDraggingAnimation(animId);
        setDraggingEdge(edge);
        setDragStartX(mouseX);

        // Find the animation being dragged
        const anim = activeAnimations.find(a => a.id === animId);
        if (anim) {
            setDragStartTime(edge === 'start' ? anim.start : edge === 'end' ? anim.end : anim.start);
        }

        // Add event listeners for drag and drop
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
    };

    // Handle drag movement
    const handleDragMove = (e) => {
        if (!draggingAnimation || !timelineRef.current) return;

        const timelineRect = timelineRef.current.getBoundingClientRect();
        const mouseX = e.clientX - timelineRect.left;
        const deltaX = mouseX - dragStartX;

        // Calculate the time delta based on the drag distance
        const timeDelta = getTimeFromPosition(deltaX, timelineRect.width);

        // Update the animation position or length
        const newAnimations = activeAnimations.map(anim => {
            if (anim.id !== draggingAnimation) return anim;

            if (draggingEdge === 'start') {
                // Dragging the start edge - update start time
                const newStart = Math.max(0, Math.min(anim.end - 0.5, dragStartTime + timeDelta));
                return { ...anim, start: newStart };
            } else if (draggingEdge === 'end') {
                // Dragging the end edge - update end time
                const newEnd = Math.max(anim.start + 0.5, Math.min(duration, dragStartTime + timeDelta));
                return { ...anim, end: newEnd };
            } else {
                // Dragging the whole animation - move both start and end
                const newStart = Math.max(0, dragStartTime + timeDelta);
                const animDuration = anim.end - anim.start;
                const newEnd = Math.min(duration, newStart + animDuration);

                // If we hit the right edge, adjust start to maintain duration
                if (newEnd === duration) {
                    return { ...anim, start: duration - animDuration, end: duration };
                }

                return { ...anim, start: newStart, end: newEnd };
            }
        });

        onAnimationsChange(newAnimations);
    };

    // End dragging
    const handleDragEnd = () => {
        setDraggingAnimation(null);
        setDraggingEdge(null);

        // Remove event listeners
        document.removeEventListener('mousemove', handleDragMove);
        document.removeEventListener('mouseup', handleDragEnd);
    };

    // Generate a color for an animation based on its index
    const getAnimationColor = (index) => {
        const colors = [
            '#4caf50', '#2196f3', '#f44336', '#ff9800', '#9c27b0',
            '#00bcd4', '#ffeb3b', '#795548', '#607d8b', '#e91e63'
        ];
        return colors[index % colors.length];
    };

    return (
        <MuiBox sx={{ width: '100%', mt: 2 }}>
            <Typography variant="subtitle2" sx={{ color: 'white', mb: 1 }}>
                Временная шкала анимаций
            </Typography>

            <MuiBox
                ref={timelineRef}
                sx={{
                    position: 'relative',
                    width: '100%',
                    height: '80px',
                    backgroundColor: 'rgba(0,0,0,0.3)',
                    borderRadius: 1,
                    overflow: 'hidden',
                    cursor: 'pointer'
                }}
            >
                {/* Time markers */}
                {Array.from({ length: Math.floor(duration / 5) + 1 }).map((_, i) => (
                    <MuiBox
                        key={i}
                        sx={{
                            position: 'absolute',
                            left: `${(i * 5 / duration) * 100}%`,
                            top: 0,
                            bottom: 0,
                            width: '1px',
                            backgroundColor: 'rgba(255,255,255,0.2)',
                            zIndex: 1,
                            '&::after': {
                                content: `"${i * 5}s"`,
                                position: 'absolute',
                                top: '2px',
                                left: '4px',
                                fontSize: '10px',
                                color: 'rgba(255,255,255,0.5)'
                            }
                        }}
                    />
                ))}

                {/* Current time indicator */}
                <MuiBox
                    sx={{
                        position: 'absolute',
                        left: `${getPositionFromTime(currentTime)}%`,
                        top: 0,
                        bottom: 0,
                        width: '2px',
                        backgroundColor: 'white',
                        zIndex: 3
                    }}
                />

                {/* Animation blocks */}
                {activeAnimations.map((anim, index) => (
                    <MuiBox
                        key={anim.id}
                        sx={{
                            position: 'absolute',
                            left: `${getPositionFromTime(anim.start)}%`,
                            width: `${getPositionFromTime(anim.end - anim.start)}%`,
                            top: `${10 + (index % 3) * 20}px`,
                            height: '18px',
                            backgroundColor: getAnimationColor(index),
                            borderRadius: '4px',
                            zIndex: 2,
                            opacity: draggingAnimation === anim.id ? 0.7 : 0.9,
                            cursor: 'move',
                            overflow: 'hidden',
                            whiteSpace: 'nowrap',
                            textOverflow: 'ellipsis',
                            fontSize: '10px',
                            padding: '2px 4px',
                            color: 'white',
                            boxSizing: 'border-box',
                            border: '1px solid rgba(255,255,255,0.3)',
                            boxShadow: '0 1px 3px rgba(0,0,0,0.3)',
                            userSelect: 'none',
                            '&:hover': {
                                boxShadow: '0 2px 5px rgba(0,0,0,0.5)'
                            }
                        }}
                        onMouseDown={(e) => handleDragStart(e, anim.id)}
                    >
                        {anim.name || `Анимация ${animations[anim.index]?.name || anim.index}`}

                        {/* Resize handles */}
                        <MuiBox
                            sx={{
                                position: 'absolute',
                                left: 0,
                                top: 0,
                                bottom: 0,
                                width: '6px',
                                cursor: 'w-resize',
                                '&:hover': {
                                    backgroundColor: 'rgba(255,255,255,0.3)'
                                }
                            }}
                            onMouseDown={(e) => handleDragStart(e, anim.id, 'start')}
                        />
                        <MuiBox
                            sx={{
                                position: 'absolute',
                                right: 0,
                                top: 0,
                                bottom: 0,
                                width: '6px',
                                cursor: 'e-resize',
                                '&:hover': {
                                    backgroundColor: 'rgba(255,255,255,0.3)'
                                }
                            }}
                            onMouseDown={(e) => handleDragStart(e, anim.id, 'end')}
                        />
                    </MuiBox>
                ))}
            </MuiBox>

            <Typography variant="caption" color="text.secondary" sx={{ display: 'block', textAlign: 'center', mt: 1 }}>
                Перетаскивайте блоки для изменения позиции. Растягивайте за края для изменения длительности.
            </Typography>
        </MuiBox>
    );
};

// Add this TabPanel component before the ModelViewer component
function TabPanel(props) {
    const { children, value, index, ...other } = props;

    return (
        <div
            role="tabpanel"
            hidden={value !== index}
            id={`model-tabpanel-${index}`}
            aria-labelledby={`model-tab-${index}`}
            {...other}
            style={{ width: '100%' }}
        >
            {value === index && (
                <MuiBox sx={{ p: 2 }}>
                    {children}
                </MuiBox>
            )}
        </div>
    );
}

const ModelViewer = ({ isVisible, onClose, playerDuration, currentTime: initialTime = 0, isPlaying: initialPlaying = false, onTimeUpdate: externalTimeUpdate, elementKeyframes = [], elementId = null, embedded = false, onSaveAnimations = null, glbAnimationUrl = null }) => {
    const [isLoading, setIsLoading] = useState(true);
    const [isPlaying, setIsPlaying] = useState(initialPlaying);
    const [currentTime, setCurrentTime] = useState(initialTime);
    const [duration, setDuration] = useState(playerDuration || 60); // Use player duration if provided
    const [modelLoaded, setModelLoaded] = useState(false);
    const [animationMarkers, setAnimationMarkers] = useState([
        { time: 0, modelTime: 0, label: 'Начало', color: '#4caf50' }
    ]);
    const [markerDialogOpen, setMarkerDialogOpen] = useState(false);
    const [currentMarker, setCurrentMarker] = useState(null);
    const [newMarkerTime, setNewMarkerTime] = useState(0);
    const [newMarkerModelTime, setNewMarkerModelTime] = useState(0);
    const [newMarkerLabel, setNewMarkerLabel] = useState('');
    const [newMarkerColor, setNewMarkerColor] = useState('#f44336');
    const [modelDuration, setModelDuration] = useState(0);
    const [activeAnimations, setActiveAnimations] = useState([]);
    const [availableAnimations, setAvailableAnimations] = useState([]);
    const [saveDialogOpen, setSaveDialogOpen] = useState(false);
    const [saveAnimationName, setSaveAnimationName] = useState('');
    const [savedAnimations, setSavedAnimations] = useState([]);
    const [loadDialogOpen, setLoadDialogOpen] = useState(false);
    const prevElementIdRef = useRef(null);
    const [selectedModel, setSelectedModel] = useState(null);
    const [uploadDialogOpen, setUploadDialogOpen] = useState(false);
    const fileInputRef = useRef(null);
    const [glbUrl, setGlbUrl] = useState('');
    const [showDebugPanel, setShowDebugPanel] = useState(false);
    const [debugInfo, setDebugInfo] = useState({
        modelUrl: glbAnimationUrl,
        modelLoaded: false,
        error: null,
        animationsCount: 0
    });

    // Add debug info update function
    const updateDebugInfo = useCallback((info) => {
        setDebugInfo(prev => ({ ...prev, ...info }));
    }, []);

    // Toggle debug panel
    const toggleDebugPanel = () => {
        setShowDebugPanel(prev => !prev);
    };

    // Load saved animations from localStorage on component mount
    useEffect(() => {
        console.log('ModelViewer: Component mounted, checking for saved animations');

        const loadSavedAnimations = () => {
            try {
                const savedData = localStorage.getItem('savedAnimations');
                if (savedData) {
                    const parsed = JSON.parse(savedData);
                    setSavedAnimations(parsed);
                    console.log(`ModelViewer: Loaded ${parsed.length} saved animations from localStorage`);
                } else {
                    console.log('ModelViewer: No saved animations found in localStorage');
                }
            } catch (error) {
                console.error('Error loading saved animations:', error);
            }
        };

        loadSavedAnimations();

        // Если у нас есть elementId и элемент содержит сохраненные анимации,
        // загружаем их из свойств элемента
        if (elementId && elementKeyframes && elementKeyframes.length > 0) {
            console.log('ModelViewer: Found element keyframes, checking for saved animations');

            // Check if any keyframe has our elementId
            const matchingKeyframes = elementKeyframes.filter(kf => kf.elementId === elementId || kf.id === elementId);

            if (matchingKeyframes.length > 0) {
                console.log('ModelViewer: Found matching keyframes for element ID:', elementId);

                // Check for glbAnimations in any matching keyframe
                const keyframeWithAnimations = matchingKeyframes.find(kf => kf.glbAnimations && kf.glbAnimations.length > 0);

                if (keyframeWithAnimations) {
                    console.log('ModelViewer: Loading saved animations from keyframe:', keyframeWithAnimations.glbAnimations);
                    setSavedAnimations(keyframeWithAnimations.glbAnimations);

                    // If this keyframe has a modelPath, use it
                    if (keyframeWithAnimations.modelPath && !selectedModel && !glbAnimationUrl) {
                        console.log('ModelViewer: Using modelPath from keyframe:', keyframeWithAnimations.modelPath);

                        setSelectedModel({
                            url: keyframeWithAnimations.modelPath,
                            name: keyframeWithAnimations.modelName || 'Saved Model',
                            id: keyframeWithAnimations.modelId
                        });
                    }
                } else {
                    console.log('ModelViewer: No glbAnimations found in matching keyframes');
                }
            } else {
                console.warn(`ModelViewer: Element with ID ${elementId} not found in keyframes`);
            }
        } else {
            console.log('ModelViewer: No element keyframes available or no elementId provided', {
                hasElementId: !!elementId,
                hasKeyframes: !!elementKeyframes,
                keyframesLength: elementKeyframes ? elementKeyframes.length : 0
            });
        }
    }, [elementId, elementKeyframes, selectedModel, glbAnimationUrl]);

    // Update state when props change
    useEffect(() => {
        if (playerDuration) {
            setDuration(playerDuration);
        }
    }, [playerDuration]);

    useEffect(() => {
        setCurrentTime(initialTime);
    }, [initialTime]);

    useEffect(() => {
        setIsPlaying(initialPlaying);
    }, [initialPlaying]);

    // Sync markers with element keyframes when they change or when element changes
    useEffect(() => {
        // Only update markers if we have valid keyframes and either the element changed or it's the initial setup
        if (elementKeyframes && elementKeyframes.length > 0 && (elementId !== prevElementIdRef.current || prevElementIdRef.current === null)) {
            console.log(`Syncing markers with ${elementKeyframes.length} keyframes from element ${elementId}`);

            // Найдем элемент в keyframes по ID
            const element = elementKeyframes.find(kf =>
                kf.id === elementId ||
                kf.elementId === elementId
            );

            if (element) {
                console.log('ModelViewer: Found matching element in keyframes:', element);

                // Если у элемента есть свои keyframes, используем их
                const keyframes = element.keyframes || [];

                if (keyframes.length > 0) {
                    console.log(`ModelViewer: Using ${keyframes.length} keyframes from element`);

                    // Convert element keyframes to animation markers
                    const newMarkers = keyframes.map((keyframe, index) => {
                        // Ensure the keyframe has a valid time
                        if (typeof keyframe.time !== 'number' || isNaN(keyframe.time)) {
                            console.warn(`Invalid keyframe time at index ${index}:`, keyframe);
                            return null;
                        }

                        // Calculate model time proportionally if not already set
                        // For first marker, use start of model animation
                        // For subsequent markers, distribute proportionally across model duration
                        const modelTime = index === 0 ? 0 : (keyframe.time / playerDuration) * modelDuration;

                        return {
                            time: keyframe.time,
                            modelTime: modelTime,
                            label: `Ключевой кадр ${index + 1}`,
                            color: index === 0 ? '#4caf50' : '#f44336'
                        };
                    }).filter(marker => marker !== null);

                    // Sort markers by time
                    newMarkers.sort((a, b) => a.time - b.time);

                    // Always ensure we have at least a start marker
                    if (newMarkers.length === 0) {
                        newMarkers.push({
                            time: 0,
                            modelTime: 0,
                            label: 'Начало',
                            color: '#4caf50'
                        });
                    }

                    // Always ensure we have an end marker
                    const hasEndMarker = newMarkers.some(marker => marker.time === playerDuration);
                    if (!hasEndMarker && playerDuration) {
                        newMarkers.push({
                            time: playerDuration,
                            modelTime: modelDuration || playerDuration,
                            label: 'Конец',
                            color: '#f44336'
                        });
                    }

                    setAnimationMarkers(newMarkers);

                    // Если у элемента есть сохраненные glbAnimations, используем их
                    if (element.glbAnimations && element.glbAnimations.length > 0) {
                        console.log('ModelViewer: Using saved glbAnimations from element:', element.glbAnimations);
                        setSavedAnimations(element.glbAnimations);

                        // Создаем активные анимации на основе сохраненных
                        if (activeAnimations.length === 0) {
                            const newActiveAnimations = element.glbAnimations.map(anim => ({
                                id: anim.id || `anim_${Date.now()}_${Math.random()}`,
                                name: anim.name || 'Анимация',
                                index: anim.index || 0,
                                start: 0,
                                end: playerDuration || modelDuration || 10,
                                weight: 1,
                                timeScale: 1
                            }));

                            console.log('ModelViewer: Created active animations from saved ones:', newActiveAnimations);
                            setActiveAnimations(newActiveAnimations);
                        }
                    }
                } else {
                    console.log('ModelViewer: Element has no keyframes, using default markers');

                    // Create default markers
                    const newMarkers = [
                        {
                            time: 0,
                            modelTime: 0,
                            label: 'Начало',
                            color: '#4caf50'
                        }
                    ];

                    // Add end marker if we have duration
                    if (playerDuration) {
                        newMarkers.push({
                            time: playerDuration,
                            modelTime: modelDuration || playerDuration,
                            label: 'Конец',
                            color: '#f44336'
                        });
                    }

                    setAnimationMarkers(newMarkers);
                }
            } else {
                console.warn(`ModelViewer: Element with ID ${elementId} not found in keyframes`);

                // Create default markers
                const newMarkers = [
                    {
                        time: 0,
                        modelTime: 0,
                        label: 'Начало',
                        color: '#4caf50'
                    }
                ];

                // Add end marker if we have duration
                if (playerDuration) {
                    newMarkers.push({
                        time: playerDuration,
                        modelTime: modelDuration || playerDuration,
                        label: 'Конец',
                        color: '#f44336'
                    });
                }

                setAnimationMarkers(newMarkers);
            }

            prevElementIdRef.current = elementId;
        }
    }, [elementKeyframes, elementId, playerDuration, modelDuration, activeAnimations.length]);

    useEffect(() => {
        // Simulate loading the engine
        const timer = setTimeout(() => {
            setIsLoading(false);
        }, 1000);

        return () => clearTimeout(timer);
    }, []);

    // Format time in MM:SS
    const formatTime = (timeInSeconds) => {
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    };

    // Handle time slider change with millisecond precision
    const handleTimeChange = (_, newValue) => {
        const time = Number(newValue.toFixed(3)); // Keep 3 decimal places for milliseconds
        setCurrentTime(time);
        if (externalTimeUpdate) {
            externalTimeUpdate(time);
        }
    };

    // Handle play/pause
    const handlePlayPause = () => {
        setIsPlaying(!isPlaying);
    };

    // Handle time update from animation
    const handleTimeUpdate = useCallback((newTime) => {
        setCurrentTime(newTime);
        if (externalTimeUpdate) {
            externalTimeUpdate(newTime);
        }
    }, [externalTimeUpdate]);

    // Handle model load with debug info
    const handleModelLoad = useCallback((animations) => {
        if (animations && animations.length > 0) {
            const animDuration = animations[0].duration;
            setModelDuration(animDuration);
            setAvailableAnimations(animations);
            setModelLoaded(true);

            updateDebugInfo({
                modelLoaded: true,
                animationsCount: animations.length,
                animationNames: animations.map(a => a.name).join(', '),
                modelDuration: animDuration
            });

            // Only use model duration if player duration is not provided
            if (!playerDuration) {
                setDuration(animDuration);
            }

            // Автоматически добавляем первую анимацию из модели
            setActiveAnimations(current => {
                // Если уже есть анимации, не добавляем новую
                if (current && current.length > 0) {
                    return current;
                }

                // Добавляем первую анимацию из загруженной модели
                const newAnimation = {
                    id: 'anim_' + Date.now() + '_' + Math.floor(Math.random() * 1000),
                    name: animations[0].name || 'Анимация 1',
                    index: 0,
                    start: 0,
                    end: playerDuration || animDuration,
                    weight: 1,
                    timeScale: 1
                };

                return [newAnimation];
            });

            // If we already have element keyframes, don't add an end marker here
            // as it will be handled by the useEffect that syncs with element keyframes
            if (elementKeyframes.length === 0) {
                // Add an end marker if none exists
                setAnimationMarkers(current => {
                    const hasEndMarker = current.some(marker => marker.time === playerDuration);
                    if (!hasEndMarker) {
                        return [
                            ...current,
                            {
                                time: playerDuration || animDuration,
                                modelTime: animDuration,
                                label: 'Конец',
                                color: '#f44336'
                            }
                        ];
                    }
                    return current;
                });
            }
        } else {
            updateDebugInfo({
                modelLoaded: false,
                error: 'No animations found in model',
                animationsCount: 0
            });
        }
    }, [playerDuration, elementKeyframes, updateDebugInfo]);

    // Add a debug panel component
    const DebugPanel = () => {
        if (!showDebugPanel) return null;

        return (
            <MuiBox
                sx={{
                    position: 'absolute',
                    top: 10,
                    left: 10,
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    color: 'white',
                    padding: 2,
                    borderRadius: 1,
                    zIndex: 1000,
                    maxWidth: 400,
                    maxHeight: 300,
                    overflow: 'auto'
                }}
            >
                <Typography variant="h6">Debug Info</Typography>
                <Typography variant="body2">Model URL: {debugInfo.modelUrl || 'None'}</Typography>
                <Typography variant="body2">Model Loaded: {debugInfo.modelLoaded ? 'Yes' : 'No'}</Typography>
                <Typography variant="body2">Animations: {debugInfo.animationsCount || 0}</Typography>
                {debugInfo.animationNames && (
                    <Typography variant="body2">Animation Names: {debugInfo.animationNames}</Typography>
                )}
                {debugInfo.error && (
                    <Typography variant="body2" sx={{ color: 'red' }}>Error: {debugInfo.error}</Typography>
                )}
                <Button
                    variant="outlined"
                    size="small"
                    onClick={() => console.log('Current debug state:', debugInfo)}
                    sx={{ mt: 1 }}
                >
                    Log Debug Info
                </Button>
            </MuiBox>
        );
    };

    // Handle model load
    const handleModelLoad = useCallback((animations) => {
        if (animations && animations.length > 0) {
            const animDuration = animations[0].duration;
            setModelDuration(animDuration);
            setAvailableAnimations(animations);
            setModelLoaded(true);

            updateDebugInfo({
                modelLoaded: true,
                animationsCount: animations.length,
                animationNames: animations.map(a => a.name).join(', '),
                modelDuration: animDuration
            });

            // Only use model duration if player duration is not provided
            if (!playerDuration) {
                setDuration(animDuration);
            }

            // Автоматически добавляем первую анимацию из модели
            setActiveAnimations(current => {
                // Если уже есть анимации, не добавляем новую
                if (current && current.length > 0) {
                    return current;
                }

                // Добавляем первую анимацию из загруженной модели
                const newAnimation = {
                    id: 'anim_' + Date.now() + '_' + Math.floor(Math.random() * 1000),
                    name: animations[0].name || 'Анимация 1',
                    index: 0,
                    start: 0,
                    end: playerDuration || animDuration,
                    weight: 1,
                    timeScale: 1
                };

                return [newAnimation];
            });

            // If we already have element keyframes, don't add an end marker here
            // as it will be handled by the useEffect that syncs with element keyframes
            if (elementKeyframes.length === 0) {
                // Add an end marker if none exists
                setAnimationMarkers(current => {
                    const hasEndMarker = current.some(marker => marker.time === playerDuration);
                    if (!hasEndMarker) {
                        return [
                            ...current,
                            {
                                time: playerDuration || animDuration,
                                modelTime: animDuration,
                                label: 'Конец',
                                color: '#f44336'
                            }
                        ];
                    }
                    return current;
                });
            }
        } else {
            updateDebugInfo({
                modelLoaded: false,
                error: 'No animations found in model',
                animationsCount: 0
            });
        }
    }, [playerDuration, elementKeyframes, updateDebugInfo]);

    // Add a new marker
    const handleAddMarker = () => {
        setCurrentMarker(null);
        setNewMarkerTime(currentTime);
        setNewMarkerModelTime(modelDuration / 2); // Default to middle of model animation
        setNewMarkerLabel(`Маркер ${animationMarkers.length + 1}`);
        setNewMarkerColor('#f44336');
        setMarkerDialogOpen(true);
    };

    // Edit an existing marker
    const handleEditMarker = (index) => {
        const marker = animationMarkers[index];
        setCurrentMarker(index);
        setNewMarkerTime(marker.time);
        setNewMarkerModelTime(marker.modelTime || 0);
        setNewMarkerLabel(marker.label || `Маркер ${index + 1}`);
        setNewMarkerColor(marker.color || '#f44336');
        setMarkerDialogOpen(true);
    };

    // Delete a marker
    const handleDeleteMarker = (index) => {
        // Don't allow deleting the first marker (start point)
        if (index === 0) return;

        setAnimationMarkers(current => current.filter((_, i) => i !== index));
    };

    // Save marker changes
    const handleSaveMarker = () => {
        if (currentMarker !== null) {
            // Edit existing marker
            setAnimationMarkers(current => {
                const updated = [...current];
                updated[currentMarker] = {
                    time: newMarkerTime,
                    modelTime: newMarkerModelTime,
                    label: newMarkerLabel,
                    color: newMarkerColor
                };
                return updated.sort((a, b) => a.time - b.time);
            });
        } else {
            // Add new marker
            setAnimationMarkers(current => {
                return [...current, {
                    time: newMarkerTime,
                    modelTime: newMarkerModelTime,
                    label: newMarkerLabel,
                    color: newMarkerColor
                }].sort((a, b) => a.time - b.time);
            });
        }
        setMarkerDialogOpen(false);
    };

    // Handle animations change
    const handleAnimationsChange = useCallback((newAnimations) => {
        setActiveAnimations(newAnimations);
    }, []);

    // Open save dialog
    const handleOpenSaveDialog = () => {
        setSaveAnimationName('');
        setSaveDialogOpen(true);
    };

    // Save current animations
    const handleSaveAnimations = () => {
        if (!saveAnimationName.trim()) return;

        try {
            // Create animation preset object
            const animationPreset = {
                id: `preset_${Date.now()}`,
                name: saveAnimationName,
                animations: activeAnimations,
                markers: animationMarkers,
                createdAt: new Date().toISOString()
            };

            // Add to saved animations
            const updatedSavedAnimations = [...savedAnimations, animationPreset];
            setSavedAnimations(updatedSavedAnimations);

            // Save to localStorage
            localStorage.setItem('savedAnimations', JSON.stringify(updatedSavedAnimations));

            // If onSaveAnimations callback is provided, call it
            if (onSaveAnimations) {
                onSaveAnimations(updatedSavedAnimations);
            }

            // Close dialog
            setSaveDialogOpen(false);
        } catch (error) {
            console.error('Error saving animations:', error);
            // Show error notification
        }
    };

    // Open load dialog
    const handleOpenLoadDialog = () => {
        setLoadDialogOpen(true);
    };

    // Load saved animation preset
    const handleLoadAnimationPreset = (preset) => {
        if (!preset) return;

        // Set active animations from preset
        if (preset.animations && preset.animations.length > 0) {
            setActiveAnimations(preset.animations);
        }

        // Set markers from preset if available
        if (preset.markers && preset.markers.length > 0) {
            setAnimationMarkers(preset.markers);
        }

        // Close dialog
        setLoadDialogOpen(false);
    };

    // Delete saved animation preset
    const handleDeleteAnimationPreset = (presetId) => {
        const updatedSavedAnimations = savedAnimations.filter(preset => preset.id !== presetId);
        setSavedAnimations(updatedSavedAnimations);
        localStorage.setItem('savedAnimations', JSON.stringify(updatedSavedAnimations));
    };

    // Handle model selection from uploader
    const handleModelSelect = (model) => {
        console.log('Selected model:', model);
        setSelectedModel(model);

        // Update the glbAnimationUrl to use the selected model
        // This will trigger the useEffect in XbotModel to load the new model
        if (model && model.url) {
            // We'll use this URL to load the model
            console.log('Setting model URL:', model.url);

            // Save the model URL immediately to ensure it's not lost
            if (onSaveAnimations) {
                const dataToSave = {
                    animations: savedAnimations.length > 0 ? savedAnimations : activeAnimations,
                    modelUrl: model.url,
                    visible: true,
                    style: {
                        opacity: 1
                    }
                };

                // If it's a blob URL, mark it as a local file
                if (model.url.startsWith('blob:')) {
                    dataToSave.isLocalFile = true;
                    dataToSave.modelName = model.name || 'Uploaded Model';
                }

                console.log('ModelViewer: Saving model URL after selection:', model.url);
                onSaveAnimations(dataToSave, elementId);
            }
        }
    };

    // Handle opening the upload dialog
    const handleOpenUploadDialog = () => {
        console.log('ModelViewer: Opening upload dialog');
        setUploadDialogOpen(true);
    };

    // Handle closing the upload dialog
    const handleCloseUploadDialog = () => {
        setUploadDialogOpen(false);
    };

    // Upload model to server
    const uploadModelToServer = async (file) => {
        console.log('ModelViewer: Uploading model to server:', file.name);
        setIsLoading(true);

        try {
            // Get authentication token from localStorage
            const token = localStorage.getItem('token');

            if (!token) {
                console.error('ModelViewer: No authentication token found');

                // Create a blob URL as fallback when not authenticated
                const url = URL.createObjectURL(file);
                console.log('ModelViewer: Not authenticated, creating blob URL as fallback:', url);

                // Set the GLB URL
                setGlbUrl(url);

                // Create a model object with the blob URL
                const modelObj = {
                    url: url,
                    name: file.name,
                    isLocalFile: true
                };

                // Set the selected model
                setSelectedModel(modelObj);

                // Save the blob URL immediately
                if (onSaveAnimations) {
                    const dataToSave = {
                        animations: savedAnimations.length > 0 ? savedAnimations : activeAnimations,
                        modelUrl: url,
                        isLocalFile: true,
                        modelName: file.name,
                        visible: true,
                        style: {
                            opacity: 1
                        }
                    };

                    console.log('ModelViewer: Saving blob URL as fallback (not authenticated):', url);
                    onSaveAnimations(dataToSave, elementId);

                    // Alert user about authentication and local file limitations
                    setTimeout(() => {
                        alert('Вы не авторизованы. Модель сохранена локально и будет доступна только в текущей сессии браузера. Для сохранения на сервере, пожалуйста, войдите в систему.');
                    }, 500);
                }

                setIsLoading(false);
                return;
            }

            console.log('ModelViewer: Using authentication token for upload');

            // Create form data
            const formData = new FormData();
            formData.append('model', file);
            formData.append('name', file.name.split('.')[0]);

            // Upload to server with proper authentication
            const response = await fetch('/api/models/upload', {
                method: 'POST',
                body: formData,
                credentials: 'include',
                headers: {
                    // Don't set Content-Type for FormData, browser will set it with boundary
                    'Authorization': `Bearer ${token}`
                }
            });

            if (!response.ok) {
                throw new Error(`Upload failed with status: ${response.status}`);
            }

            const modelData = await response.json();
            console.log('ModelViewer: Model uploaded successfully:', modelData);

            // Create a model object with the server URL
            const modelObj = {
                url: modelData.url,
                name: modelData.name,
                id: modelData.id
            };

            // Set the selected model
            setSelectedModel(modelObj);

            // Save the model URL immediately
            if (onSaveAnimations) {
                const dataToSave = {
                    animations: savedAnimations.length > 0 ? savedAnimations : activeAnimations,
                    modelUrl: modelData.url,
                    modelId: modelData.id,
                    visible: true,
                    style: {
                        opacity: 1
                    }
                };

                console.log('ModelViewer: Saving server model URL:', modelData.url);
                onSaveAnimations(dataToSave, elementId);

                // Show success message
                alert('Модель успешно загружена на сервер и сохранена!');
            }

            setUploadDialogOpen(false);
        } catch (error) {
            console.error('ModelViewer: Error uploading model to server:', error);
            alert(`Ошибка загрузки модели на сервер: ${error.message}. Используем локальную версию.`);

            // Fallback to blob URL if server upload fails
            const url = URL.createObjectURL(file);
            setGlbUrl(url);

            // Create a model object with the blob URL
            const modelObj = {
                url: url,
                name: file.name,
                isLocalFile: true
            };

            // Set the selected model
            setSelectedModel(modelObj);

            // Save the blob URL immediately
            if (onSaveAnimations) {
                const dataToSave = {
                    animations: savedAnimations.length > 0 ? savedAnimations : activeAnimations,
                    modelUrl: url,
                    isLocalFile: true,
                    modelName: file.name,
                    visible: true,
                    style: {
                        opacity: 1
                    }
                };

                console.log('ModelViewer: Saving blob URL as fallback:', url);
                onSaveAnimations(dataToSave, elementId);

                // Alert user about local file limitations
                setTimeout(() => {
                    alert('Внимание: Модель сохранена локально и будет доступна только в текущей сессии браузера. При перезагрузке страницы вам потребуется загрузить модель заново.');
                }, 500);
            }
        } finally {
            setIsLoading(false);
        }
    };

    // Handle file input change
    const handleFileInputChange = (event) => {
        const file = event.target.files[0];
        if (file) {
            console.log('ModelViewer: File selected:', file.name);

            // Try to upload to server first
            uploadModelToServer(file);

            // Close dialog
            setUploadDialogOpen(false);
        }
    };

    // Handle GLB URL submit
    const handleGlbUrlSubmit = () => {
        if (glbUrl) {
            console.log('ModelViewer: Submitting GLB URL:', glbUrl);

            // Create a model object similar to what ModelUploader would return
            const modelObj = {
                url: glbUrl,
                name: glbUrl.split('/').pop() || 'Uploaded GLB'
            };

            // Set the selected model
            setSelectedModel(modelObj);

            // Also update the active animations to include this model
            if (activeAnimations.length === 0) {
                // Add a default animation for the entire duration
                const newAnimation = {
                    id: 'anim_' + Date.now() + '_' + Math.floor(Math.random() * 1000),
                    name: 'Default Animation',
                    index: 0,
                    start: 0,
                    end: playerDuration || 10,
                    weight: 1,
                    timeScale: 1
                };
                setActiveAnimations([newAnimation]);
            }

            // Close the dialog without saving automatically
            setUploadDialogOpen(false);

            // Inform the user that they need to click the save button
            alert('Модель загружена. Нажмите кнопку "Сохранить модель", чтобы сохранить её.');
        }
    };

    // Handle close with saving animations
    const handleClose = () => {
        console.log('ModelViewer: Closing viewer, preparing to save model data');

        // Если есть callback для сохранения, вызываем его
        if (onSaveAnimations) {
            // Определяем URL модели
            const modelUrl = selectedModel ? selectedModel.url : glbAnimationUrl;

            console.log('ModelViewer: Preparing to save on close:', {
                selectedModel: selectedModel ? {
                    name: selectedModel.name,
                    url: selectedModel.url
                } : 'none',
                glbAnimationUrl: glbAnimationUrl || 'none',
                finalModelUrl: modelUrl || 'none',
                elementId: elementId || 'none',
                savedAnimationsCount: savedAnimations.length
            });

            // Проверяем, что URL модели действителен
            if (!modelUrl) {
                console.warn('ModelViewer: No valid model URL found for saving');
                closeViewerWithoutSaving();
                return;
            }

            // Check if it's a blob URL that needs to be uploaded to the server
            if (modelUrl && modelUrl.startsWith('blob:')) {
                console.log('ModelViewer: Detected blob URL on close, uploading to server first');

                // Get the model name
                const modelName = selectedModel ? selectedModel.name : 'Uploaded Model';

                // Fetch the blob and convert to file
                fetch(modelUrl)
                    .then(response => response.blob())
                    .then(blob => {
                        // Create a File object from the blob
                        const file = new File([blob], modelName + '.glb', { type: 'model/gltf-binary' });
                        // Upload to server and then close
                        uploadModelAndClose(file);
                    })
                    .catch(error => {
                        console.error('ModelViewer: Error converting blob to file on close:', error);
                        // Fallback to using the blob URL
                        saveAndClose(modelUrl);
                    });
            } else {
                // Not a blob URL, save directly and close
                saveAndClose(modelUrl);
            }
        } else {
            console.error('ModelViewer: Cannot save - no onSaveAnimations callback provided');
            closeViewerWithoutSaving();
        }
    };

    // Helper function to upload model and close
    const uploadModelAndClose = async (file) => {
        console.log('ModelViewer: Uploading model to server before closing:', file.name);
        setIsLoading(true);

        try {
            // Get authentication token from localStorage
            const token = localStorage.getItem('token');

            if (!token) {
                console.error('ModelViewer: No authentication token found');
                throw new Error('Authentication required. Please log in.');
            }

            // Create form data
            const formData = new FormData();
            formData.append('model', file);
            formData.append('name', file.name.split('.')[0]);

            // Upload to server with authentication
            const response = await fetch('/api/models/upload', {
                method: 'POST',
                body: formData,
                credentials: 'include',
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (!response.ok) {
                throw new Error(`Upload failed with status: ${response.status}`);
            }

            const modelData = await response.json();
            console.log('ModelViewer: Model uploaded successfully before closing:', modelData);

            // Save with the server URL and close
            saveAndClose(modelData.url, modelData.id);
        } catch (error) {
            console.error('ModelViewer: Error uploading model to server on close:', error);
            // Fallback to blob URL
            const blobUrl = selectedModel ? selectedModel.url : glbAnimationUrl;
            saveAndClose(blobUrl);
        } finally {
            setIsLoading(false);
        }
    };

    // Helper function to save and close
    const saveAndClose = (modelUrl, modelId = null) => {
        // Создаем объект с анимациями и URL модели
        const dataToSave = {
            animations: savedAnimations.length > 0 ? savedAnimations : activeAnimations,
            modelUrl: modelUrl,
            visible: true,
            style: {
                opacity: 1 // Ensure opacity is set to fully visible
            }
        };

        // If we have a model ID from the server, add it
        if (modelId) {
            dataToSave.modelId = modelId;
        }

        // Если URL модели начинается с blob:, это локальный файл, который нужно обработать особым образом
        if (modelUrl && modelUrl.startsWith('blob:')) {
            console.log('ModelViewer: Detected blob URL for model, will handle as local file');

            // Сохраняем информацию о том, что это локальный файл
            dataToSave.isLocalFile = true;

            // Если это локальный файл, добавляем имя файла, если оно доступно
            if (selectedModel && selectedModel.name) {
                dataToSave.modelName = selectedModel.name;
            }
        }

        console.log('ModelViewer: Saving model data on close:', {
            hasModel: !!modelUrl,
            modelUrl: modelUrl || 'не указан',
            animationsCount: dataToSave.animations.length,
            elementId: elementId || 'не указан',
            visible: dataToSave.visible,
            opacity: dataToSave.style?.opacity || 1,
            dataToSave: JSON.stringify(dataToSave).substring(0, 100) + '...'
        });

        // Make sure we're passing the correct elementId
        const targetElementId = elementId;

        // Force save the model URL before closing
        try {
            // Вызываем callback с данными для сохранения
            onSaveAnimations(dataToSave, targetElementId);
            console.log('ModelViewer: onSaveAnimations callback executed with elementId:', targetElementId);

            // Показываем уведомление с подробной информацией
            const modelName = selectedModel ? selectedModel.name : 'Модель';
            const animInfo = dataToSave.animations.length > 0
                ? `и ${dataToSave.animations.length} анимаций`
                : '';

            alert(`${modelName} ${animInfo} успешно сохранена!`);
            closeViewerWithoutSaving();
        } catch (error) {
            console.error('ModelViewer: Error saving model:', error);
            alert('Ошибка при сохранении модели: ' + error.message);
            closeViewerWithoutSaving();
        }
    };

    // Helper function to close without saving
    const closeViewerWithoutSaving = () => {
        // Вызываем onClose из props
        if (onClose) {
            console.log('ModelViewer: Calling onClose callback');
            onClose();
        } else {
            console.warn('ModelViewer: No onClose callback provided');
        }
    };

    // Save model button
    const handleSaveModel = () => {
        console.log('ModelViewer: Save model button clicked');

        if (!selectedModel && !glbAnimationUrl) {
            alert('Сначала загрузите модель!');
            return;
        }

        if (onSaveAnimations) {
            // Определяем URL модели
            const modelUrl = selectedModel ? selectedModel.url : glbAnimationUrl;

            // Check if it's a blob URL that needs to be uploaded to the server
            if (modelUrl && modelUrl.startsWith('blob:')) {
                console.log('ModelViewer: Detected blob URL, uploading to server first');

                // Get the model name
                const modelName = selectedModel ? selectedModel.name : 'Uploaded Model';

                // Fetch the blob and convert to file
                fetch(modelUrl)
                    .then(response => response.blob())
                    .then(blob => {
                        // Create a File object from the blob
                        const file = new File([blob], modelName + '.glb', { type: 'model/gltf-binary' });
                        // Upload to server
                        uploadModelToServer(file);
                    })
                    .catch(error => {
                        console.error('ModelViewer: Error converting blob to file:', error);
                        // Fallback to using the blob URL
                        saveModelWithUrl(modelUrl);
                    });
            } else {
                // Not a blob URL, save directly
                saveModelWithUrl(modelUrl);
            }
        } else {
            console.error('ModelViewer: Cannot save - no onSaveAnimations callback provided');
            alert('Ошибка: Невозможно сохранить модель. Обратитесь к разработчику.');
        }
    };

    // Helper function to save model with URL
    const saveModelWithUrl = (modelUrl) => {
        // Создаем объект с анимациями и URL модели
        const dataToSave = {
            animations: savedAnimations.length > 0 ? savedAnimations : activeAnimations,
            modelUrl: modelUrl,
            visible: true,
            style: {
                opacity: 1
            }
        };

        // Если URL модели начинается с blob:, это локальный файл
        if (modelUrl && modelUrl.startsWith('blob:')) {
            dataToSave.isLocalFile = true;
            if (selectedModel && selectedModel.name) {
                dataToSave.modelName = selectedModel.name;
            }
        }

        console.log('ModelViewer: Manual save of model:', {
            modelUrl: modelUrl,
            elementId: elementId
        });

        try {
            onSaveAnimations(dataToSave, elementId);
            alert('Модель успешно сохранена!');
        } catch (error) {
            console.error('ModelViewer: Error saving model:', error);
            alert('Ошибка при сохранении модели: ' + error.message);
        }
    };

    if (!isVisible) return null;

    return (
        <MuiBox
            sx={{
                position: embedded ? 'relative' : 'fixed',
                top: embedded ? 'auto' : 0,
                left: embedded ? 'auto' : 0,
                width: '100%',
                height: '100%',
                zIndex: embedded ? 'auto' : 1000,
                backgroundColor: embedded ? 'transparent' : 'rgba(0, 0, 0, 0.85)',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: embedded ? 2 : 0,
                overflow: 'hidden',
                overscrollBehavior: 'contain',
                touchAction: 'pan-y',
            }}
        >
            {isLoading ? (
                <MuiBox sx={{ color: 'white', textAlign: 'center' }}>
                    <CircularProgress color="primary" size={60} />
                    <MuiBox mt={2}>Загрузка 3D движка...</MuiBox>
                </MuiBox>
            ) : (
                <>
                    <MuiBox sx={{ width: '100%', height: embedded ? '100%' : '70%', position: 'relative' }}>
                        {/* Canvas container */}
                        <MuiBox
                            sx={{
                                width: '100%',
                                height: '100%',
                                backgroundColor: '#1a1a1a', // Темный фон для 3D сцены
                                borderRadius: embedded ? 2 : 0,
                                overflow: 'hidden',
                                position: 'relative',
                                border: embedded ? '1px solid rgba(255, 255, 255, 0.1)' : 'none',
                                boxShadow: embedded ? 'inset 0 0 20px rgba(0, 0, 0, 0.5)' : 'none',
                                '& > div': {
                                    touchAction: 'none',
                                    overscrollBehavior: 'contain',
                                    '&:focus-visible': {
                                        outline: 'none'
                                    }
                                }
                            }}
                        >
                            <Canvas style={{ background: '#111' }}>
                                <ambientLight intensity={0.6} />
                                <directionalLight position={[5, 5, 5]} intensity={1} castShadow />
                                <directionalLight position={[-5, 5, 5]} intensity={0.5} />
                                <directionalLight position={[0, 5, -5]} intensity={0.5} />
                                <PerspectiveCamera makeDefault position={[0, 2, 10]} />
                                <Suspense fallback={null}>
                                    <XbotModel
                                        currentTime={currentTime}
                                        isPlaying={isPlaying}
                                        onTimeUpdate={handleTimeUpdate}
                                        onModelLoad={handleModelLoad}
                                        playerDuration={playerDuration}
                                        animationMarkers={animationMarkers}
                                        activeAnimations={activeAnimations}
                                        glbAnimationUrl={selectedModel ? selectedModel.url : glbAnimationUrl}
                                        elementId={elementId}
                                        elementKeyframes={elementKeyframes}
                                    />
                                    <Grid
                                        position={[0, -1, 0]}
                                        args={[10, 10]}
                                        cellSize={1}
                                        cellThickness={1}
                                        cellColor="#555"
                                        sectionSize={3}
                                        sectionThickness={1.5}
                                        sectionColor="#888"
                                        fadeDistance={30}
                                    />
                                </Suspense>
                                <OrbitControls
                                    makeDefault
                                    enableDamping
                                    dampingFactor={0.1}
                                    rotateSpeed={0.5}
                                    enableZoom={true}
                                    zoomSpeed={0.8}
                                    enablePan={true}
                                    panSpeed={0.5}
                                />
                            </Canvas>

                            {/* Debug button */}
                            <IconButton
                                onClick={toggleDebugPanel}
                                sx={{
                                    position: 'absolute',
                                    bottom: 10,
                                    right: 10,
                                    backgroundColor: 'rgba(0,0,0,0.5)',
                                    color: 'white',
                                    '&:hover': {
                                        backgroundColor: 'rgba(0,0,0,0.7)'
                                    }
                                }}
                            >
                                <span style={{ fontSize: '12px' }}>DEBUG</span>
                            </IconButton>

                            {/* Debug panel */}
                            <DebugPanel />
                        </MuiBox>
                    </MuiBox>

                    {/* Controls */}
                    <MuiBox
                        sx={{
                            width: '100%',
                            display: 'flex',
                            flexDirection: 'column',
                            alignItems: 'center',
                            mt: 2,
                            px: 2,
                            backgroundColor: embedded ? 'rgba(0, 0, 0, 0.5)' : 'transparent',
                            borderRadius: embedded ? 1 : 0,
                            py: embedded ? 1 : 0
                        }}
                    >
                        {/* Animation controls */}
                        <MuiBox sx={{ width: '100%', display: 'flex', alignItems: 'center', mb: 1 }}>
                            <IconButton
                                onClick={handlePlayPause}
                                sx={{
                                    color: 'white',
                                    mr: 1,
                                }}
                            >
                                {isPlaying ? <Pause /> : <PlayArrow />}
                            </IconButton>

                            <Typography variant="body2" sx={{ color: 'white', mr: 1, minWidth: '60px' }}>
                                {formatTime(currentTime)}
                            </Typography>

                            <MarkedSlider
                                value={currentTime}
                                min={0}
                                max={duration}
                                onChange={handleTimeChange}
                                markers={animationMarkers}
                                disabled={false}
                                onMarkerAdd={handleAddMarker}
                                onMarkerEdit={handleEditMarker}
                                onMarkerDelete={handleDeleteMarker}
                            />

                            <Typography variant="body2" sx={{ color: 'white', ml: 1 }}>
                                {formatTime(duration)}
                            </Typography>
                        </MuiBox>

                        {/* Upload GLB button and animation controls */}
                        <MuiBox sx={{ width: '100%', display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                            <Button
                                variant="contained"
                                color="primary"
                                onClick={handleOpenUploadDialog}
                                startIcon={<Upload />}
                            >
                                Загрузить GLB
                            </Button>

                            {selectedModel && (
                                <Typography variant="body2" color="text.secondary">
                                    Загружено: {selectedModel.name}
                                </Typography>
                            )}

                            <Button
                                variant="contained"
                                color="secondary"
                                onClick={handleSaveModel}
                                startIcon={<Save />}
                                sx={{ ml: 2 }}
                            >
                                Сохранить модель
                            </Button>
                        </MuiBox>

                        <AnimationManager
                            animations={availableAnimations}
                            activeAnimations={activeAnimations}
                            onAnimationsChange={handleAnimationsChange}
                        />

                        <AnimationTimeline
                            animations={availableAnimations}
                            activeAnimations={activeAnimations}
                            duration={duration}
                            currentTime={currentTime}
                            onAnimationsChange={handleAnimationsChange}
                        />

                        <Typography variant="caption" color="text.secondary" sx={{ display: 'block', textAlign: 'center', mt: 1 }}>
                            {elementId ?
                                `Маркеры синхронизированы с ключевыми кадрами элемента. ${elementKeyframes.length} ключевых кадров.` :
                                'Маркеры не синхронизированы с элементами.'}
                        </Typography>
                    </MuiBox>

                    {!embedded && (
                        <MuiBox sx={{ position: 'absolute', top: 20, right: 20, zIndex: 100, display: 'flex', gap: 1 }}>
                            <Button
                                variant="contained"
                                color="primary"
                                startIcon={<Save />}
                                onClick={() => {
                                    if (onSaveAnimations) {
                                        // Определяем URL модели
                                        const modelUrl = selectedModel ? selectedModel.url : glbAnimationUrl;

                                        // Создаем объект с анимациями и URL модели
                                        const dataToSave = {
                                            animations: savedAnimations,
                                            modelUrl: modelUrl
                                        };

                                        // Если URL модели начинается с blob:, это локальный файл, который нужно обработать особым образом
                                        if (modelUrl && modelUrl.startsWith('blob:')) {
                                            console.log('ModelViewer: Detected blob URL for model, will handle as local file');

                                            // Сохраняем информацию о том, что это локальный файл
                                            dataToSave.isLocalFile = true;

                                            // Если это локальный файл, добавляем имя файла, если оно доступно
                                            if (selectedModel && selectedModel.name) {
                                                dataToSave.modelName = selectedModel.name;
                                            }
                                        }

                                        console.log('ModelViewer: Saving model data on button click:', {
                                            hasModel: !!selectedModel,
                                            modelName: selectedModel ? selectedModel.name : 'не выбрана',
                                            modelUrl: dataToSave.modelUrl || 'не указан',
                                            animationsCount: savedAnimations.length,
                                            elementId: elementId || 'не указан'
                                        });

                                        // Вызываем callback с данными для сохранения
                                        onSaveAnimations(dataToSave, elementId);

                                        // Показываем уведомление с подробной информацией
                                        const modelName = selectedModel ? selectedModel.name : 'Модель';
                                        const animInfo = savedAnimations.length > 0
                                            ? `и ${savedAnimations.length} анимаций`
                                            : '';

                                        alert(`${modelName} ${animInfo} успешно сохранена!`);
                                    } else {
                                        console.error('ModelViewer: Cannot save - no onSaveAnimations callback provided');
                                        alert('Ошибка: Невозможно сохранить модель. Обратитесь к разработчику.');
                                    }
                                }}
                                sx={{
                                    backgroundColor: 'primary.main',
                                    color: 'white',
                                    '&:hover': {
                                        backgroundColor: 'primary.dark',
                                    }
                                }}
                            >
                                Сохранить
                            </Button>
                            <IconButton
                                onClick={handleClose}
                                sx={{
                                    backgroundColor: 'rgba(0, 0, 0, 0.5)',
                                    color: 'white',
                                    '&:hover': {
                                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                    }
                                }}
                            >
                                <CloseIcon />
                            </IconButton>
                        </MuiBox>
                    )}
                </>
            )}

            {/* Marker Dialog */}
            <Dialog open={markerDialogOpen} onClose={() => setMarkerDialogOpen(false)}>
                <DialogTitle>
                    {currentMarker !== null ? 'Редактировать маркер' : 'Добавить маркер'}
                </DialogTitle>
                <DialogContent>
                    <TextField
                        margin="dense"
                        label="Время (секунды)"
                        type="number"
                        fullWidth
                        value={newMarkerTime}
                        onChange={(e) => setNewMarkerTime(Number(e.target.value))}
                        inputProps={{ step: 0.1, min: 0, max: duration }}
                        sx={{ mb: 2 }}
                    />
                    <TextField
                        margin="dense"
                        label="Время модели (секунды)"
                        type="number"
                        fullWidth
                        value={newMarkerModelTime}
                        onChange={(e) => setNewMarkerModelTime(Number(e.target.value))}
                        inputProps={{ step: 0.1, min: 0, max: modelDuration }}
                        sx={{ mb: 2 }}
                        helperText={`Время в анимации модели (от 0 до ${modelDuration.toFixed(2)} секунд)`}
                    />
                    <TextField
                        margin="dense"
                        label="Название"
                        type="text"
                        fullWidth
                        value={newMarkerLabel}
                        onChange={(e) => setNewMarkerLabel(e.target.value)}
                        sx={{ mb: 2 }}
                    />
                    <TextField
                        margin="dense"
                        label="Цвет"
                        type="color"
                        fullWidth
                        value={newMarkerColor}
                        onChange={(e) => setNewMarkerColor(e.target.value)}
                        sx={{ mb: 2 }}
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setMarkerDialogOpen(false)}>Отмена</Button>
                    <Button onClick={handleSaveMarker} color="primary">Сохранить</Button>
                </DialogActions>
            </Dialog>

            {/* Save Animation Dialog */}
            <Dialog open={saveDialogOpen} onClose={() => setSaveDialogOpen(false)}>
                <DialogTitle>
                    Сохранить анимацию
                </DialogTitle>
                <DialogContent>
                    <TextField
                        autoFocus
                        margin="dense"
                        label="Название анимации"
                        type="text"
                        fullWidth
                        value={saveAnimationName}
                        onChange={(e) => setSaveAnimationName(e.target.value)}
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setSaveDialogOpen(false)}>Отмена</Button>
                    <Button onClick={handleSaveAnimations} color="primary" disabled={!saveAnimationName.trim()}>
                        Сохранить
                    </Button>
                </DialogActions>
            </Dialog>

            {/* Load Animation Dialog */}
            <Dialog open={loadDialogOpen} onClose={() => setLoadDialogOpen(false)} maxWidth="sm" fullWidth>
                <DialogTitle>
                    Загрузить анимацию
                </DialogTitle>
                <DialogContent>
                    {savedAnimations.length === 0 ? (
                        <Typography variant="body2" color="text.secondary" sx={{ textAlign: 'center', py: 2 }}>
                            Нет сохраненных анимаций
                        </Typography>
                    ) : (
                        <List>
                            {savedAnimations.map((preset) => (
                                <ListItem
                                    key={preset.id}
                                    button
                                    onClick={() => handleLoadAnimationPreset(preset)}
                                    secondaryAction={
                                        <IconButton edge="end" onClick={() => handleDeleteAnimationPreset(preset.id)}>
                                            <Delete />
                                        </IconButton>
                                    }
                                >
                                    <ListItemText
                                        primary={preset.name}
                                        secondary={`Создано: ${new Date(preset.createdAt).toLocaleString()}`}
                                    />
                                </ListItem>
                            ))}
                        </List>
                    )}
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setLoadDialogOpen(false)}>Закрыть</Button>
                </DialogActions>
            </Dialog>

            {/* Upload GLB Dialog */}
            <Dialog open={uploadDialogOpen} onClose={handleCloseUploadDialog}>
                <DialogTitle>
                    Загрузить GLB модель
                </DialogTitle>
                <DialogContent>
                    <Typography variant="body2" sx={{ mb: 2 }}>
                        Выберите .glb файл с моделью и анимациями или введите URL
                    </Typography>

                    <input
                        type="file"
                        accept=".glb"
                        style={{ display: 'none' }}
                        ref={fileInputRef}
                        onChange={handleFileInputChange}
                    />

                    <Button
                        variant="contained"
                        onClick={() => {
                            console.log('ModelViewer: File input button clicked');
                            if (fileInputRef.current) {
                                fileInputRef.current.click();
                            } else {
                                console.error('ModelViewer: File input ref is null');
                            }
                        }}
                        sx={{ mb: 2 }}
                        fullWidth
                    >
                        Выбрать файл
                    </Button>

                    <Typography variant="body2" sx={{ mt: 2, mb: 1 }}>
                        Или введите URL:
                    </Typography>

                    <TextField
                        margin="dense"
                        label="URL .glb файла"
                        type="text"
                        fullWidth
                        value={glbUrl}
                        onChange={(e) => setGlbUrl(e.target.value)}
                        sx={{ mb: 2 }}
                        placeholder="https://example.com/model.glb"
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleCloseUploadDialog}>Отмена</Button>
                    <Button
                        onClick={handleGlbUrlSubmit}
                        color="primary"
                        disabled={!glbUrl}
                    >
                        Загрузить
                    </Button>
                </DialogActions>
            </Dialog>
        </MuiBox>
    );
};

export default ModelViewer;