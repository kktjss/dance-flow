import React, { useRef, useState, useEffect, Suspense, useCallback } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera, useGLTF, Grid } from '@react-three/drei';
import { Box as MuiBox, CircularProgress, Button, IconButton, Slider, Typography, Tooltip, Dialog, DialogTitle, DialogContent, DialogActions, TextField, List, ListItem, ListItemText, ListItemSecondaryAction, Menu, MenuItem, Select, FormControl, InputLabel } from '@mui/material';
import { PlayArrow, Pause, AddCircleOutline, Delete, Edit, DragIndicator, Save, FolderOpen } from '@mui/icons-material';
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

// Model component for Xbot
const XbotModel = ({ currentTime, isPlaying, onTimeUpdate, onModelLoad, playerDuration, animationMarkers = [], activeAnimations = [], glbAnimationUrl = null }) => {
    console.log('XbotModel: Loading model from /models/xbot.glb');
    const gltf = useGLTF('/models/xbot.glb');
    console.log('XbotModel: Model loaded via useGLTF:', gltf);
    console.log('XbotModel: Model scene:', gltf.scene);
    console.log('XbotModel: Model animations:', gltf.animations);

    const mixer = useRef(null);
    const lastTimeRef = useRef(null);
    const animationRef = useRef(null);
    const clock = useRef(new THREE.Clock());
    const modelDuration = useRef(0);
    const animationsRef = useRef([]);
    const activeActionsRef = useRef({});
    const [externalAnimations, setExternalAnimations] = useState({});
    const [customModel, setCustomModel] = useState(null);
    const [loadingError, setLoadingError] = useState(null);
    const [isLoading, setIsLoading] = useState(false);

    // Load custom GLB model if URL is provided
    useEffect(() => {
        if (glbAnimationUrl) {
            console.log('XbotModel: Loading custom GLB model from URL:', glbAnimationUrl);
            console.log('XbotModel: URL type:', typeof glbAnimationUrl);
            console.log('XbotModel: Full URL details:', {
                url: glbAnimationUrl,
                length: glbAnimationUrl.length,
                startsWithHttp: glbAnimationUrl.startsWith('http'),
                containsGlb: glbAnimationUrl.includes('.glb')
            });

            setIsLoading(true);
            setLoadingError(null);

            // Преобразование относительного URL в абсолютный, если необходимо
            const processedUrl = glbAnimationUrl.startsWith('/') && !glbAnimationUrl.startsWith('//')
                ? `${window.location.origin}${glbAnimationUrl}`
                : glbAnimationUrl;

            console.log('XbotModel: Processed URL for loading:', processedUrl);

            const loadModel = async () => {
                try {
                    console.log('XbotModel: Starting to load model from URL:', processedUrl);

                    // Use GLTFLoader directly
                    const loader = new GLTFLoader();
                    loader.load(
                        processedUrl,
                        (gltf) => {
                            console.log('XbotModel: Custom model loaded successfully with animations:', gltf.animations);

                            // Apply default transformations to the model
                            gltf.scene.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });

                            setCustomModel({ scene: gltf.scene, animations: gltf.animations });

                            // Pass animations to parent if available
                            if (gltf.animations && gltf.animations.length > 0) {
                                onModelLoad(gltf.animations);
                            }

                            setIsLoading(false);
                        },
                        (xhr) => {
                            console.log(`Loading progress: ${Math.round(xhr.loaded / xhr.total * 100)}%`);
                        },
                        (error) => {
                            console.error('XbotModel: Error loading custom GLB model:', error);
                            setLoadingError(`Ошибка загрузки модели: ${error.message}`);
                            setIsLoading(false);
                        }
                    );
                } catch (error) {
                    console.error('XbotModel: Error in loadModel function:', error);
                    setLoadingError(`Ошибка загрузки модели: ${error.message}`);
                    setIsLoading(false);
                }
            };

            loadModel();
        } else {
            setCustomModel(null);
            setLoadingError(null);
            setIsLoading(false);
        }
    }, [glbAnimationUrl, onModelLoad]);

    // Initialize animation mixer
    useEffect(() => {
        // Use custom model if available, otherwise use default Xbot model
        const model = customModel || gltf;

        if (model && model.animations && model.animations.length > 0) {
            console.log('XbotModel: Model loaded successfully with animations:', model.animations);
            console.log('XbotModel: Animation names:', model.animations.map(anim => anim.name));

            // Create a new mixer for the current model
            mixer.current = new THREE.AnimationMixer(model.scene);
            animationsRef.current = model.animations;

            // Store original model animation duration from the first animation
            modelDuration.current = model.animations[0].duration;
            console.log('XbotModel: Model duration:', modelDuration.current);

            // Pass animations to parent
            onModelLoad(model.animations);
        } else {
            console.warn('XbotModel: Model loaded but no animations found:', model);
        }
    }, [gltf, customModel, onModelLoad]);

    // Load external animation
    const loadExternalAnimation = useCallback(async (url) => {
        if (!url || externalAnimations[url]) return;

        try {
            console.log('XbotModel: Loading external animation from URL:', url);

            // Use GLTFLoader directly
            const loader = new GLTFLoader();
            loader.load(
                url,
                (gltf) => {
                    const animations = gltf.animations;

                    if (animations && animations.length > 0) {
                        console.log(`Loaded ${animations.length} animations from ${url}`);

                        // Store animations with their URL as key
                        setExternalAnimations(prev => ({
                            ...prev,
                            [url]: animations
                        }));

                        // Add to available animations
                        const newAnimations = [...animationsRef.current];
                        animations.forEach(anim => {
                            // Set a custom property to identify external animations
                            anim.isExternal = true;
                            anim.sourceUrl = url;
                            newAnimations.push(anim);
                        });

                        animationsRef.current = newAnimations;

                        // Notify parent about new animations
                        onModelLoad(newAnimations);
                    }
                },
                (xhr) => {
                    console.log(`Loading animation progress: ${Math.round(xhr.loaded / xhr.total * 100)}%`);
                },
                (error) => {
                    console.error(`Error loading animation from ${url}:`, error);
                }
            );
        } catch (error) {
            console.error(`Error in loadExternalAnimation for ${url}:`, error);
        }
    }, [externalAnimations, onModelLoad]);

    // Update active animations when the activeAnimations prop changes
    useEffect(() => {
        if (!mixer.current) return;

        // Load any external animations first
        activeAnimations.forEach(anim => {
            if (anim.url) {
                loadExternalAnimation(anim.url);
            }
        });

        // Stop all current actions
        Object.values(activeActionsRef.current).forEach(action => {
            if (action) action.stop();
        });

        // Reset active actions
        activeActionsRef.current = {};

        // Create new actions for each active animation
        activeAnimations.forEach(anim => {
            // Find the animation by name, index, or from external source
            let animation;

            if (anim.url && externalAnimations[anim.url]) {
                // Find animation in external animations
                const externalAnims = externalAnimations[anim.url];
                animation = externalAnims[anim.externalIndex || 0];
            } else {
                // Find in default animations
                animation = typeof anim.index === 'number'
                    ? animationsRef.current[anim.index]
                    : animationsRef.current.find(a => a.name === anim.name);
            }

            if (animation) {
                const action = mixer.current.clipAction(animation);
                action.setLoop(THREE.LoopRepeat);
                action.clampWhenFinished = true;
                action.play();

                // Store the action reference
                activeActionsRef.current[anim.id] = action;

                // Set time scale if specified
                if (typeof anim.timeScale === 'number') {
                    action.timeScale = anim.timeScale;
                }

                // Set weight if specified (for blending)
                if (typeof anim.weight === 'number') {
                    action.weight = anim.weight;
                }
            }
        });
    }, [activeAnimations, externalAnimations, loadExternalAnimation]);

    // Find the current animation segment based on markers
    const getCurrentAnimationSegment = useCallback(() => {
        if (!animationMarkers || animationMarkers.length === 0) {
            return { start: 0, end: modelDuration.current, modelStart: 0, modelEnd: modelDuration.current };
        }

        // Sort markers by time
        const sortedMarkers = [...animationMarkers].sort((a, b) => a.time - b.time);

        // Find the current segment
        for (let i = 0; i < sortedMarkers.length - 1; i++) {
            if (currentTime >= sortedMarkers[i].time && currentTime < sortedMarkers[i + 1].time) {
                return {
                    start: sortedMarkers[i].time,
                    end: sortedMarkers[i + 1].time,
                    modelStart: sortedMarkers[i].modelTime,
                    modelEnd: sortedMarkers[i + 1].modelTime
                };
            }
        }

        // If we're past the last marker, loop back to the first segment
        if (currentTime >= sortedMarkers[sortedMarkers.length - 1].time) {
            return {
                start: sortedMarkers[sortedMarkers.length - 1].time,
                end: playerDuration,
                modelStart: sortedMarkers[sortedMarkers.length - 1].modelTime,
                modelEnd: modelDuration.current
            };
        }

        // Default to the first segment
        return {
            start: 0,
            end: sortedMarkers[0]?.time || playerDuration,
            modelStart: 0,
            modelEnd: sortedMarkers[0]?.modelTime || modelDuration.current
        };
    }, [currentTime, animationMarkers, playerDuration]);

    // Find the active animation at the current time
    const getActiveAnimationAtTime = useCallback(() => {
        if (!activeAnimations || activeAnimations.length === 0) {
            return [];
        }

        // Find animations that are active at the current time
        return activeAnimations.filter(anim =>
            currentTime >= anim.start && currentTime <= anim.end
        );
    }, [currentTime, activeAnimations]);

    // Update animation time when scrubbing
    useEffect(() => {
        if (mixer.current && !isPlaying) {
            // Get active animations at current time
            const activeAnimsAtTime = getActiveAnimationAtTime();

            // If no animations are active at this time, use the default behavior with markers
            if (activeAnimsAtTime.length === 0) {
                let scaledTime;

                if (animationMarkers && animationMarkers.length > 0) {
                    // Use markers for precise animation segment mapping
                    const segment = getCurrentAnimationSegment();
                    const segmentProgress = (currentTime - segment.start) / (segment.end - segment.start);
                    scaledTime = segment.modelStart + segmentProgress * (segment.modelEnd - segment.modelStart);
                } else {
                    // Default scaling when no markers are present
                    scaledTime = playerDuration
                        ? (currentTime / playerDuration) * modelDuration.current
                        : currentTime;
                }

                mixer.current.time = scaledTime;
                return;
            }

            // For each active animation, set its time based on the current player time
            activeAnimsAtTime.forEach(anim => {
                const action = activeActionsRef.current[anim.id];
                if (action) {
                    // Calculate the progress within this animation's time range
                    const animProgress = (currentTime - anim.start) / (anim.end - anim.start);

                    // Calculate the model time based on the animation's duration
                    const animation = animationsRef.current[anim.index];
                    if (animation) {
                        const animDuration = animation.duration;
                        const modelTime = animProgress * animDuration;

                        // Set the action time directly
                        action.time = modelTime;
                    }
                }
            });
        }
    }, [currentTime, isPlaying, playerDuration, animationMarkers, getCurrentAnimationSegment, getActiveAnimationAtTime]);

    // Animation loop with precise timing
    const animate = useCallback((timestamp) => {
        if (!lastTimeRef.current) {
            lastTimeRef.current = timestamp;
        }

        const elapsed = timestamp - lastTimeRef.current;

        if (mixer.current && isPlaying) {
            const delta = clock.current.getDelta();
            mixer.current.update(delta);

            // Update time approximately 30 times per second
            if (elapsed > 33) { // ~30fps
                // Get active animations at current time
                const activeAnimsAtTime = getActiveAnimationAtTime();

                // Update player time based on animation progress
                let playerTime = currentTime + delta;

                // If we have active animations at this time, check if we need to adjust the player time
                if (activeAnimsAtTime.length > 0) {
                    // Check if we've reached the end of any animation segment
                    const endingAnims = activeAnimsAtTime.filter(anim => playerTime >= anim.end);
                    if (endingAnims.length > 0) {
                        // If we've reached the end of all active animations, loop back or stop
                        if (endingAnims.length === activeAnimsAtTime.length) {
                            // If we've reached the end of the player duration, loop back to start
                            if (playerTime >= playerDuration) {
                                playerTime = 0;
                                mixer.current.time = 0;
                            }
                        }
                    }
                } else {
                    // Default behavior when no animations are active at this time
                    if (animationMarkers && animationMarkers.length > 0) {
                        // Use markers for precise animation segment mapping
                        const segment = getCurrentAnimationSegment();
                        const modelTime = mixer.current.time;
                        const segmentProgress = (modelTime - segment.modelStart) / (segment.modelEnd - segment.modelStart);
                        playerTime = segment.start + segmentProgress * (segment.end - segment.start);

                        // Check if we've reached the end of the segment
                        if (playerTime >= segment.end) {
                            playerTime = segment.end;
                        }
                    } else {
                        // Default scaling when no markers are present
                        const modelTime = mixer.current.time;
                        playerTime = playerDuration
                            ? (modelTime / modelDuration.current) * playerDuration
                            : modelTime;
                    }

                    // Check if we've reached the end of the player duration
                    if (playerTime >= playerDuration) {
                        playerTime = 0;
                        mixer.current.time = 0;
                    }
                }

                onTimeUpdate(playerTime);
                lastTimeRef.current = timestamp;
            }
        }

        if (isPlaying) {
            animationRef.current = requestAnimationFrame(animate);
        }
    }, [isPlaying, onTimeUpdate, playerDuration, animationMarkers, getCurrentAnimationSegment, currentTime, getActiveAnimationAtTime]);

    // Setup and cleanup animation frame
    useEffect(() => {
        if (isPlaying) {
            clock.current.start();
            lastTimeRef.current = null;
            animationRef.current = requestAnimationFrame(animate);
        } else {
            clock.current.stop();
        }

        return () => {
            if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
                animationRef.current = null;
            }
        };
    }, [isPlaying, animate]);

    // Handle animation end
    useEffect(() => {
        if (mixer.current && playerDuration && currentTime >= playerDuration) {
            onTimeUpdate(0);
            mixer.current.time = 0;
        }
    }, [currentTime, playerDuration, onTimeUpdate]);

    return (
        <>
            {isLoading && (
                <mesh position={[0, 0, 0]}>
                    <sphereGeometry args={[0.5, 16, 16]} />
                    <meshStandardMaterial color="#4285F4" wireframe />
                </mesh>
            )}

            {loadingError && (
                <>
                    <mesh position={[0, 0, 0]}>
                        <boxGeometry args={[1, 1, 1]} />
                        <meshStandardMaterial color="red" />
                    </mesh>
                    <mesh position={[0, 1.5, 0]}>
                        <textGeometry args={[`Ошибка: ${loadingError}`]} />
                        <meshStandardMaterial color="white" />
                    </mesh>
                </>
            )}

            {!isLoading && !loadingError && (
                <>
                    {/* Render the appropriate model */}
                    {customModel ? (
                        <primitive
                            object={customModel.scene}
                            scale={[1.0, 1.0, 1.0]}
                            position={[0, 0, 0]}
                            rotation={[0, 0, 0]}
                        />
                    ) : (
                        <primitive
                            object={gltf.scene}
                            scale={[1.0, 1.0, 1.0]}
                            position={[0, 0, 0]}
                            rotation={[0, 0, 0]}
                        />
                    )}
                </>
            )}
            <gridHelper args={[10, 10]} />
        </>
    );
};

// Custom Slider with markers
const MarkedSlider = ({ value, min, max, onChange, markers = [], disabled, onMarkerAdd, onMarkerEdit, onMarkerDelete }) => {
    const getMarkerPosition = (time) => ((time - min) / (max - min)) * 100;

    return (
        <MuiBox sx={{ position: 'relative', width: '100%', mx: 2 }}>
            <Slider
                value={value}
                min={min}
                max={max}
                onChange={onChange}
                step={0.001}
                disabled={disabled}
                sx={{ zIndex: 1 }}
            />
            {markers.map((marker, index) => (
                <Tooltip
                    key={index}
                    title={`${marker.label || `Маркер ${index + 1}`} (${marker.time.toFixed(2)}с)`}
                    arrow
                >
                    <MuiBox
                        onClick={(e) => {
                            e.stopPropagation();
                            onMarkerEdit(index);
                        }}
                        onContextMenu={(e) => {
                            e.preventDefault();
                            onMarkerDelete(index);
                        }}
                        sx={{
                            position: 'absolute',
                            left: `${getMarkerPosition(marker.time)}%`,
                            top: '50%',
                            transform: 'translate(-50%, -50%)',
                            width: '12px',
                            height: '12px',
                            backgroundColor: marker.color || '#f44336',
                            borderRadius: '50%',
                            border: '2px solid white',
                            zIndex: 2,
                            cursor: 'pointer',
                            '&:hover': {
                                transform: 'translate(-50%, -50%) scale(1.2)',
                                boxShadow: '0 0 5px rgba(0,0,0,0.3)'
                            }
                        }}
                    />
                </Tooltip>
            ))}
            <IconButton
                size="small"
                onClick={onMarkerAdd}
                sx={{
                    position: 'absolute',
                    right: '-30px',
                    top: '50%',
                    transform: 'translateY(-50%)',
                    zIndex: 2,
                    backgroundColor: 'rgba(0,0,0,0.1)',
                    '&:hover': {
                        backgroundColor: 'rgba(0,0,0,0.2)'
                    }
                }}
            >
                <AddCircleOutline fontSize="small" />
            </IconButton>
        </MuiBox>
    );
};

// Animation Manager Component
const AnimationManager = ({ animations = [], activeAnimations = [], onAnimationsChange }) => {
    const [anchorEl, setAnchorEl] = useState(null);
    const [selectedAnimIndex, setSelectedAnimIndex] = useState(null);
    const [animationDialogOpen, setAnimationDialogOpen] = useState(false);
    const [currentAnimation, setCurrentAnimation] = useState(null);
    const [uploadDialogOpen, setUploadDialogOpen] = useState(false);
    const [animationUrl, setAnimationUrl] = useState('');
    const fileInputRef = useRef(null);

    // Animation dialog form state
    const [animName, setAnimName] = useState('');
    const [animIndex, setAnimIndex] = useState(0);
    const [animStart, setAnimStart] = useState(0);
    const [animEnd, setAnimEnd] = useState(10);
    const [animWeight, setAnimWeight] = useState(1);
    const [animTimeScale, setAnimTimeScale] = useState(1);
    const [animUrl, setAnimUrl] = useState('');
    const [animExternalIndex, setAnimExternalIndex] = useState(0);

    // Generate a unique ID for new animations
    const generateUniqueId = () => {
        return 'anim_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    };

    // Open context menu for an animation
    const handleAnimationMenuOpen = (event, index) => {
        event.preventDefault();
        event.stopPropagation();
        setAnchorEl(event.currentTarget);
        setSelectedAnimIndex(index);
    };

    // Close context menu
    const handleAnimationMenuClose = () => {
        setAnchorEl(null);
        setSelectedAnimIndex(null);
    };

    // Open dialog to add a new animation
    const handleAddAnimation = () => {
        setCurrentAnimation(null);

        // Set default values for a new animation
        setAnimName('');
        setAnimIndex(0);
        setAnimStart(0);
        setAnimEnd(10);
        setAnimWeight(1);
        setAnimTimeScale(1);
        setAnimUrl('');
        setAnimExternalIndex(0);

        setAnimationDialogOpen(true);
    };

    // Open dialog to edit an existing animation
    const handleEditAnimation = () => {
        const anim = activeAnimations[selectedAnimIndex];

        setCurrentAnimation(anim);
        setAnimName(anim.name || '');
        setAnimIndex(anim.index || 0);
        setAnimStart(anim.start || 0);
        setAnimEnd(anim.end || 10);
        setAnimWeight(anim.weight || 1);
        setAnimTimeScale(anim.timeScale || 1);
        setAnimUrl(anim.url || '');
        setAnimExternalIndex(anim.externalIndex || 0);

        setAnimationDialogOpen(true);
        handleAnimationMenuClose();
    };

    // Delete an animation
    const handleDeleteAnimation = () => {
        const newAnimations = [...activeAnimations];
        newAnimations.splice(selectedAnimIndex, 1);
        onAnimationsChange(newAnimations);
        handleAnimationMenuClose();
    };

    // Save animation changes
    const handleSaveAnimation = () => {
        if (currentAnimation) {
            // Update existing animation
            const newAnimations = activeAnimations.map(anim =>
                anim.id === currentAnimation.id
                    ? {
                        ...anim,
                        name: animName,
                        index: animIndex,
                        start: animStart,
                        end: animEnd,
                        weight: animWeight,
                        timeScale: animTimeScale,
                        url: animUrl,
                        externalIndex: animExternalIndex
                    }
                    : anim
            );
            onAnimationsChange(newAnimations);
        } else {
            // Add new animation
            const newAnimation = {
                id: generateUniqueId(),
                name: animName,
                index: animIndex,
                start: animStart,
                end: animEnd,
                weight: animWeight,
                timeScale: animTimeScale,
                url: animUrl,
                externalIndex: animExternalIndex
            };
            onAnimationsChange([...activeAnimations, newAnimation]);
        }

        setAnimationDialogOpen(false);
    };

    // Open upload dialog
    const handleOpenUploadDialog = () => {
        setUploadDialogOpen(true);
    };

    // Close upload dialog
    const handleCloseUploadDialog = () => {
        setUploadDialogOpen(false);
    };

    // Handle file input change
    const handleFileInputChange = (event) => {
        const file = event.target.files[0];
        if (file) {
            const url = URL.createObjectURL(file);
            setAnimationUrl(url);
        }
    };

    // Handle animation URL submit
    const handleAnimationUrlSubmit = () => {
        setAnimUrl(animationUrl);
        setUploadDialogOpen(false);

        // If we're in the animation dialog, update the URL there
        if (animationDialogOpen) {
            setAnimUrl(animationUrl);
        } else {
            // Otherwise, create a new animation with this URL
            const newAnimation = {
                id: generateUniqueId(),
                name: `Анимация из ${animationUrl.split('/').pop()}`,
                start: 0,
                end: 10,
                weight: 1,
                timeScale: 1,
                url: animationUrl,
                externalIndex: 0
            };
            onAnimationsChange([...activeAnimations, newAnimation]);
        }
    };

    return (
        <>
            <MuiBox sx={{ width: '100%', mt: 2, color: 'white' }}>
                <Typography variant="subtitle1" gutterBottom>
                    Анимации ({activeAnimations.length})
                    <IconButton
                        size="small"
                        onClick={handleAddAnimation}
                        sx={{ ml: 1, color: 'white' }}
                    >
                        <AddCircleOutline />
                    </IconButton>
                </Typography>

                <Button
                    variant="outlined"
                    color="primary"
                    onClick={handleOpenUploadDialog}
                    sx={{ mb: 2 }}
                >
                    Загрузить .glb анимацию
                </Button>

                {activeAnimations.length === 0 ? (
                    <Typography variant="body2" color="text.secondary">
                        Нет активных анимаций. Нажмите + чтобы добавить или загрузите .glb файл.
                    </Typography>
                ) : (
                    <List dense sx={{ bgcolor: 'rgba(0,0,0,0.3)', borderRadius: 1 }}>
                        {activeAnimations.map((anim, index) => (
                            <ListItem
                                key={anim.id}
                                sx={{
                                    borderBottom: index < activeAnimations.length - 1 ? '1px solid rgba(255,255,255,0.1)' : 'none',
                                    '&:hover': { bgcolor: 'rgba(255,255,255,0.05)' }
                                }}
                                secondaryAction={
                                    <IconButton
                                        edge="end"
                                        size="small"
                                        onClick={(e) => handleAnimationMenuOpen(e, index)}
                                        sx={{ color: 'white' }}
                                    >
                                        <Edit fontSize="small" />
                                    </IconButton>
                                }
                            >
                                <DragIndicator sx={{ mr: 1, opacity: 0.5, fontSize: '1rem' }} />
                                <ListItemText
                                    primary={anim.name || (anim.url ? `Анимация из ${anim.url.split('/').pop()}` : `Анимация ${animations[anim.index]?.name || anim.index}`)}
                                    secondary={
                                        <>
                                            {`${anim.start}с - ${anim.end}с (скорость: ${anim.timeScale}x)`}
                                            {anim.url && <Typography variant="caption" component="div" sx={{ color: 'primary.light' }}>
                                                Внешняя анимация
                                            </Typography>}
                                        </>
                                    }
                                    primaryTypographyProps={{ variant: 'body2' }}
                                    secondaryTypographyProps={{ variant: 'caption' }}
                                />
                            </ListItem>
                        ))}
                    </List>
                )}
            </MuiBox>

            {/* Animation Context Menu */}
            <Menu
                anchorEl={anchorEl}
                open={Boolean(anchorEl)}
                onClose={handleAnimationMenuClose}
            >
                <MenuItem onClick={handleEditAnimation}>
                    <Edit fontSize="small" sx={{ mr: 1 }} /> Редактировать
                </MenuItem>
                <MenuItem onClick={handleDeleteAnimation}>
                    <Delete fontSize="small" sx={{ mr: 1 }} /> Удалить
                </MenuItem>
            </Menu>

            {/* Animation Edit Dialog */}
            <Dialog open={animationDialogOpen} onClose={() => setAnimationDialogOpen(false)}>
                <DialogTitle>
                    {currentAnimation ? 'Редактировать анимацию' : 'Добавить анимацию'}
                </DialogTitle>
                <DialogContent>
                    <TextField
                        margin="dense"
                        label="Название"
                        type="text"
                        fullWidth
                        value={animName}
                        onChange={(e) => setAnimName(e.target.value)}
                        sx={{ mb: 2 }}
                    />

                    {/* Выбор между встроенной и внешней анимацией */}
                    <Typography variant="subtitle2" gutterBottom>
                        Источник анимации:
                    </Typography>

                    {!animUrl ? (
                        <>
                            <FormControl fullWidth margin="dense" sx={{ mb: 2 }}>
                                <InputLabel>Встроенная анимация</InputLabel>
                                <Select
                                    value={animIndex}
                                    onChange={(e) => setAnimIndex(Number(e.target.value))}
                                    label="Встроенная анимация"
                                >
                                    {animations.filter(anim => !anim.isExternal).map((anim, index) => (
                                        <MenuItem key={index} value={index}>
                                            {anim.name || `Анимация ${index + 1}`}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>

                            <Button
                                variant="outlined"
                                onClick={handleOpenUploadDialog}
                                sx={{ mb: 2 }}
                            >
                                Использовать внешнюю анимацию
                            </Button>
                        </>
                    ) : (
                        <>
                            <TextField
                                margin="dense"
                                label="URL анимации"
                                type="text"
                                fullWidth
                                value={animUrl}
                                disabled
                                sx={{ mb: 1 }}
                            />

                            <TextField
                                margin="dense"
                                label="Индекс анимации в файле"
                                type="number"
                                fullWidth
                                value={animExternalIndex}
                                onChange={(e) => setAnimExternalIndex(Number(e.target.value))}
                                inputProps={{ min: 0 }}
                                sx={{ mb: 2 }}
                                helperText="Индекс анимации в файле (обычно 0 для первой анимации)"
                            />

                            <Button
                                variant="outlined"
                                onClick={() => setAnimUrl('')}
                                sx={{ mb: 2 }}
                            >
                                Использовать встроенную анимацию
                            </Button>
                        </>
                    )}

                    <TextField
                        margin="dense"
                        label="Начало (секунды)"
                        type="number"
                        fullWidth
                        value={animStart}
                        onChange={(e) => setAnimStart(Number(e.target.value))}
                        inputProps={{ step: 0.1, min: 0 }}
                        sx={{ mb: 2 }}
                    />

                    <TextField
                        margin="dense"
                        label="Конец (секунды)"
                        type="number"
                        fullWidth
                        value={animEnd}
                        onChange={(e) => setAnimEnd(Number(e.target.value))}
                        inputProps={{ step: 0.1, min: animStart }}
                        sx={{ mb: 2 }}
                    />

                    <TextField
                        margin="dense"
                        label="Вес (для смешивания)"
                        type="number"
                        fullWidth
                        value={animWeight}
                        onChange={(e) => setAnimWeight(Number(e.target.value))}
                        inputProps={{ step: 0.1, min: 0, max: 1 }}
                        sx={{ mb: 2 }}
                        helperText="От 0 до 1, используется для смешивания анимаций"
                    />

                    <TextField
                        margin="dense"
                        label="Скорость воспроизведения"
                        type="number"
                        fullWidth
                        value={animTimeScale}
                        onChange={(e) => setAnimTimeScale(Number(e.target.value))}
                        inputProps={{ step: 0.1, min: 0.1 }}
                        helperText="1 = нормальная скорость, 0.5 = замедленно, 2 = ускоренно"
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setAnimationDialogOpen(false)}>Отмена</Button>
                    <Button onClick={handleSaveAnimation} color="primary">Сохранить</Button>
                </DialogActions>
            </Dialog>

            {/* Upload Animation Dialog */}
            <Dialog open={uploadDialogOpen} onClose={handleCloseUploadDialog}>
                <DialogTitle>
                    Загрузить анимацию
                </DialogTitle>
                <DialogContent>
                    <Typography variant="body2" sx={{ mb: 2 }}>
                        Выберите .glb файл с анимацией или введите URL
                    </Typography>

                    <input
                        type="file"
                        accept=".glb"
                        style={{ display: 'none' }}
                        ref={fileInputRef}
                        onChange={handleFileInputChange}
                    />

                    <Button
                        variant="contained"
                        onClick={() => fileInputRef.current.click()}
                        sx={{ mb: 2 }}
                    >
                        Выбрать файл
                    </Button>

                    <Typography variant="body2" sx={{ mt: 2, mb: 1 }}>
                        Или введите URL:
                    </Typography>

                    <TextField
                        margin="dense"
                        label="URL .glb файла"
                        type="text"
                        fullWidth
                        value={animationUrl}
                        onChange={(e) => setAnimationUrl(e.target.value)}
                        sx={{ mb: 2 }}
                        placeholder="https://example.com/animation.glb"
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleCloseUploadDialog}>Отмена</Button>
                    <Button
                        onClick={handleAnimationUrlSubmit}
                        color="primary"
                        disabled={!animationUrl}
                    >
                        Добавить
                    </Button>
                </DialogActions>
            </Dialog>
        </>
    );
};

// Animation Timeline Component
const AnimationTimeline = ({ animations = [], activeAnimations = [], duration = 60, currentTime = 0, onAnimationsChange }) => {
    const [draggingAnimation, setDraggingAnimation] = useState(null);
    const [draggingEdge, setDraggingEdge] = useState(null); // 'start' or 'end'
    const [dragStartX, setDragStartX] = useState(0);
    const [dragStartTime, setDragStartTime] = useState(0);
    const timelineRef = useRef(null);

    // Calculate position on timeline from time
    const getPositionFromTime = (time) => {
        return (time / duration) * 100;
    };

    // Calculate time from position on timeline
    const getTimeFromPosition = (position, width) => {
        const percent = position / width;
        return Math.max(0, Math.min(duration, percent * duration));
    };

    // Start dragging an animation
    const handleDragStart = (e, animId, edge = null) => {
        e.preventDefault();
        e.stopPropagation();

        const timelineRect = timelineRef.current.getBoundingClientRect();
        const mouseX = e.clientX - timelineRect.left;

        setDraggingAnimation(animId);
        setDraggingEdge(edge);
        setDragStartX(mouseX);

        // Find the animation being dragged
        const anim = activeAnimations.find(a => a.id === animId);
        if (anim) {
            setDragStartTime(edge === 'start' ? anim.start : edge === 'end' ? anim.end : anim.start);
        }

        // Add event listeners for drag and drop
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
    };

    // Handle drag movement
    const handleDragMove = (e) => {
        if (!draggingAnimation || !timelineRef.current) return;

        const timelineRect = timelineRef.current.getBoundingClientRect();
        const mouseX = e.clientX - timelineRect.left;
        const deltaX = mouseX - dragStartX;

        // Calculate the time delta based on the drag distance
        const timeDelta = getTimeFromPosition(deltaX, timelineRect.width);

        // Update the animation position or length
        const newAnimations = activeAnimations.map(anim => {
            if (anim.id !== draggingAnimation) return anim;

            if (draggingEdge === 'start') {
                // Dragging the start edge - update start time
                const newStart = Math.max(0, Math.min(anim.end - 0.5, dragStartTime + timeDelta));
                return { ...anim, start: newStart };
            } else if (draggingEdge === 'end') {
                // Dragging the end edge - update end time
                const newEnd = Math.max(anim.start + 0.5, Math.min(duration, dragStartTime + timeDelta));
                return { ...anim, end: newEnd };
            } else {
                // Dragging the whole animation - move both start and end
                const newStart = Math.max(0, dragStartTime + timeDelta);
                const animDuration = anim.end - anim.start;
                const newEnd = Math.min(duration, newStart + animDuration);

                // If we hit the right edge, adjust start to maintain duration
                if (newEnd === duration) {
                    return { ...anim, start: duration - animDuration, end: duration };
                }

                return { ...anim, start: newStart, end: newEnd };
            }
        });

        onAnimationsChange(newAnimations);
    };

    // End dragging
    const handleDragEnd = () => {
        setDraggingAnimation(null);
        setDraggingEdge(null);

        // Remove event listeners
        document.removeEventListener('mousemove', handleDragMove);
        document.removeEventListener('mouseup', handleDragEnd);
    };

    // Generate a color for an animation based on its index
    const getAnimationColor = (index) => {
        const colors = [
            '#4caf50', '#2196f3', '#f44336', '#ff9800', '#9c27b0',
            '#00bcd4', '#ffeb3b', '#795548', '#607d8b', '#e91e63'
        ];
        return colors[index % colors.length];
    };

    return (
        <MuiBox sx={{ width: '100%', mt: 2 }}>
            <Typography variant="subtitle2" sx={{ color: 'white', mb: 1 }}>
                Временная шкала анимаций
            </Typography>

            <MuiBox
                ref={timelineRef}
                sx={{
                    position: 'relative',
                    width: '100%',
                    height: '80px',
                    backgroundColor: 'rgba(0,0,0,0.3)',
                    borderRadius: 1,
                    overflow: 'hidden',
                    cursor: 'pointer'
                }}
            >
                {/* Time markers */}
                {Array.from({ length: Math.floor(duration / 5) + 1 }).map((_, i) => (
                    <MuiBox
                        key={i}
                        sx={{
                            position: 'absolute',
                            left: `${(i * 5 / duration) * 100}%`,
                            top: 0,
                            bottom: 0,
                            width: '1px',
                            backgroundColor: 'rgba(255,255,255,0.2)',
                            zIndex: 1,
                            '&::after': {
                                content: `"${i * 5}s"`,
                                position: 'absolute',
                                top: '2px',
                                left: '4px',
                                fontSize: '10px',
                                color: 'rgba(255,255,255,0.5)'
                            }
                        }}
                    />
                ))}

                {/* Current time indicator */}
                <MuiBox
                    sx={{
                        position: 'absolute',
                        left: `${getPositionFromTime(currentTime)}%`,
                        top: 0,
                        bottom: 0,
                        width: '2px',
                        backgroundColor: 'white',
                        zIndex: 3
                    }}
                />

                {/* Animation blocks */}
                {activeAnimations.map((anim, index) => (
                    <MuiBox
                        key={anim.id}
                        sx={{
                            position: 'absolute',
                            left: `${getPositionFromTime(anim.start)}%`,
                            width: `${getPositionFromTime(anim.end - anim.start)}%`,
                            top: `${10 + (index % 3) * 20}px`,
                            height: '18px',
                            backgroundColor: getAnimationColor(index),
                            borderRadius: '4px',
                            zIndex: 2,
                            opacity: draggingAnimation === anim.id ? 0.7 : 0.9,
                            cursor: 'move',
                            overflow: 'hidden',
                            whiteSpace: 'nowrap',
                            textOverflow: 'ellipsis',
                            fontSize: '10px',
                            padding: '2px 4px',
                            color: 'white',
                            boxSizing: 'border-box',
                            border: '1px solid rgba(255,255,255,0.3)',
                            boxShadow: '0 1px 3px rgba(0,0,0,0.3)',
                            userSelect: 'none',
                            '&:hover': {
                                boxShadow: '0 2px 5px rgba(0,0,0,0.5)'
                            }
                        }}
                        onMouseDown={(e) => handleDragStart(e, anim.id)}
                    >
                        {anim.name || `Анимация ${animations[anim.index]?.name || anim.index}`}

                        {/* Resize handles */}
                        <MuiBox
                            sx={{
                                position: 'absolute',
                                left: 0,
                                top: 0,
                                bottom: 0,
                                width: '6px',
                                cursor: 'w-resize',
                                '&:hover': {
                                    backgroundColor: 'rgba(255,255,255,0.3)'
                                }
                            }}
                            onMouseDown={(e) => handleDragStart(e, anim.id, 'start')}
                        />
                        <MuiBox
                            sx={{
                                position: 'absolute',
                                right: 0,
                                top: 0,
                                bottom: 0,
                                width: '6px',
                                cursor: 'e-resize',
                                '&:hover': {
                                    backgroundColor: 'rgba(255,255,255,0.3)'
                                }
                            }}
                            onMouseDown={(e) => handleDragStart(e, anim.id, 'end')}
                        />
                    </MuiBox>
                ))}
            </MuiBox>

            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)', mt: 0.5, display: 'block' }}>
                Перетаскивайте блоки для изменения позиции. Растягивайте за края для изменения длительности.
            </Typography>
        </MuiBox>
    );
};

const ModelViewer = ({ isVisible, onClose, playerDuration, currentTime: initialTime = 0, isPlaying: initialPlaying = false, onTimeUpdate: externalTimeUpdate, elementKeyframes = [], elementId = null, embedded = false, onSaveAnimations = null, glbAnimationUrl = null }) => {
    const [isLoading, setIsLoading] = useState(true);
    const [isPlaying, setIsPlaying] = useState(initialPlaying);
    const [currentTime, setCurrentTime] = useState(initialTime);
    const [duration, setDuration] = useState(playerDuration || 60); // Use player duration if provided
    const [modelLoaded, setModelLoaded] = useState(false);
    const [animationMarkers, setAnimationMarkers] = useState([
        { time: 0, modelTime: 0, label: 'Начало', color: '#4caf50' }
    ]);
    const [markerDialogOpen, setMarkerDialogOpen] = useState(false);
    const [currentMarker, setCurrentMarker] = useState(null);
    const [newMarkerTime, setNewMarkerTime] = useState(0);
    const [newMarkerModelTime, setNewMarkerModelTime] = useState(0);
    const [newMarkerLabel, setNewMarkerLabel] = useState('');
    const [newMarkerColor, setNewMarkerColor] = useState('#f44336');
    const [modelDuration, setModelDuration] = useState(0);
    const [activeAnimations, setActiveAnimations] = useState([]);
    const [availableAnimations, setAvailableAnimations] = useState([]);
    const [saveDialogOpen, setSaveDialogOpen] = useState(false);
    const [saveAnimationName, setSaveAnimationName] = useState('');
    const [savedAnimations, setSavedAnimations] = useState([]);
    const [loadDialogOpen, setLoadDialogOpen] = useState(false);
    const prevElementIdRef = useRef(null);

    // Load saved animations from localStorage on component mount
    useEffect(() => {
        const loadSavedAnimations = () => {
            try {
                const savedData = localStorage.getItem('savedAnimations');
                if (savedData) {
                    const parsed = JSON.parse(savedData);
                    setSavedAnimations(parsed);
                }
            } catch (error) {
                console.error('Error loading saved animations:', error);
            }
        };

        loadSavedAnimations();
    }, []);

    // Update state when props change
    useEffect(() => {
        if (playerDuration) {
            setDuration(playerDuration);
        }
    }, [playerDuration]);

    useEffect(() => {
        setCurrentTime(initialTime);
    }, [initialTime]);

    useEffect(() => {
        setIsPlaying(initialPlaying);
    }, [initialPlaying]);

    // Sync markers with element keyframes when they change or when element changes
    useEffect(() => {
        // Only update markers if we have valid keyframes and either the element changed or it's the initial setup
        if (elementKeyframes && elementKeyframes.length > 0 && (elementId !== prevElementIdRef.current || prevElementIdRef.current === null)) {
            console.log(`Syncing markers with ${elementKeyframes.length} keyframes from element ${elementId}`);

            // Convert element keyframes to animation markers
            const newMarkers = elementKeyframes.map((keyframe, index) => {
                // Ensure the keyframe has a valid time
                if (typeof keyframe.time !== 'number' || isNaN(keyframe.time)) {
                    console.warn(`Invalid keyframe time at index ${index}:`, keyframe);
                    return null;
                }

                // Calculate model time proportionally if not already set
                // For first marker, use start of model animation
                // For subsequent markers, distribute proportionally across model duration
                const modelTime = index === 0 ? 0 : (keyframe.time / playerDuration) * modelDuration;

                return {
                    time: keyframe.time,
                    modelTime: modelTime,
                    label: `Ключевой кадр ${index + 1}`,
                    color: index === 0 ? '#4caf50' : '#f44336'
                };
            }).filter(marker => marker !== null);

            // Always ensure we have at least a start marker
            if (newMarkers.length === 0) {
                newMarkers.push({
                    time: 0,
                    modelTime: 0,
                    label: 'Начало',
                    color: '#4caf50'
                });
            }

            // Always ensure we have an end marker
            const hasEndMarker = newMarkers.some(marker => marker.time === playerDuration);
            if (!hasEndMarker) {
                newMarkers.push({
                    time: playerDuration || modelDuration,
                    modelTime: modelDuration,
                    label: 'Конец',
                    color: '#f44336'
                });
            }

            // Sort markers by time
            newMarkers.sort((a, b) => a.time - b.time);

            setAnimationMarkers(newMarkers);
            prevElementIdRef.current = elementId;
        }
    }, [elementKeyframes, elementId, playerDuration, modelDuration]);

    useEffect(() => {
        // Simulate loading the engine
        const timer = setTimeout(() => {
            setIsLoading(false);
        }, 1000);

        return () => clearTimeout(timer);
    }, []);

    // Format time in MM:SS
    const formatTime = (timeInSeconds) => {
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    };

    // Handle time slider change with millisecond precision
    const handleTimeChange = (_, newValue) => {
        const time = Number(newValue.toFixed(3)); // Keep 3 decimal places for milliseconds
        setCurrentTime(time);
        if (externalTimeUpdate) {
            externalTimeUpdate(time);
        }
    };

    // Handle play/pause
    const handlePlayPause = () => {
        setIsPlaying(!isPlaying);
    };

    // Handle time update from animation
    const handleTimeUpdate = useCallback((newTime) => {
        setCurrentTime(newTime);
        if (externalTimeUpdate) {
            externalTimeUpdate(newTime);
        }
    }, [externalTimeUpdate]);

    // Handle model load
    const handleModelLoad = useCallback((animations) => {
        if (animations && animations.length > 0) {
            const animDuration = animations[0].duration;
            setModelDuration(animDuration);
            setAvailableAnimations(animations);

            // Only use model duration if player duration is not provided
            if (!playerDuration) {
                setDuration(animDuration);
            }

            // We no longer add default animation automatically
            // Let the user add animations explicitly

            setModelLoaded(true);

            // If we already have element keyframes, don't add an end marker here
            // as it will be handled by the useEffect that syncs with element keyframes
            if (elementKeyframes.length === 0) {
                // Add an end marker if none exists
                setAnimationMarkers(current => {
                    const hasEndMarker = current.some(marker => marker.time === playerDuration);
                    if (!hasEndMarker) {
                        return [
                            ...current,
                            {
                                time: playerDuration || animDuration,
                                modelTime: animDuration,
                                label: 'Конец',
                                color: '#f44336'
                            }
                        ];
                    }
                    return current;
                });
            }
        }
    }, [playerDuration, elementKeyframes]);

    // Add a new marker
    const handleAddMarker = () => {
        setCurrentMarker(null);
        setNewMarkerTime(currentTime);
        setNewMarkerModelTime(modelDuration / 2); // Default to middle of model animation
        setNewMarkerLabel(`Маркер ${animationMarkers.length + 1}`);
        setNewMarkerColor('#f44336');
        setMarkerDialogOpen(true);
    };

    // Edit an existing marker
    const handleEditMarker = (index) => {
        const marker = animationMarkers[index];
        setCurrentMarker(index);
        setNewMarkerTime(marker.time);
        setNewMarkerModelTime(marker.modelTime || 0);
        setNewMarkerLabel(marker.label || `Маркер ${index + 1}`);
        setNewMarkerColor(marker.color || '#f44336');
        setMarkerDialogOpen(true);
    };

    // Delete a marker
    const handleDeleteMarker = (index) => {
        // Don't allow deleting the first marker (start point)
        if (index === 0) return;

        setAnimationMarkers(current => current.filter((_, i) => i !== index));
    };

    // Save marker changes
    const handleSaveMarker = () => {
        if (currentMarker !== null) {
            // Edit existing marker
            setAnimationMarkers(current => {
                const updated = [...current];
                updated[currentMarker] = {
                    time: newMarkerTime,
                    modelTime: newMarkerModelTime,
                    label: newMarkerLabel,
                    color: newMarkerColor
                };
                return updated.sort((a, b) => a.time - b.time);
            });
        } else {
            // Add new marker
            setAnimationMarkers(current => {
                return [...current, {
                    time: newMarkerTime,
                    modelTime: newMarkerModelTime,
                    label: newMarkerLabel,
                    color: newMarkerColor
                }].sort((a, b) => a.time - b.time);
            });
        }
        setMarkerDialogOpen(false);
    };

    // Handle animations change
    const handleAnimationsChange = useCallback((newAnimations) => {
        setActiveAnimations(newAnimations);
    }, []);

    // Open save dialog
    const handleOpenSaveDialog = () => {
        setSaveAnimationName('');
        setSaveDialogOpen(true);
    };

    // Save current animations
    const handleSaveAnimations = () => {
        if (!saveAnimationName.trim()) return;

        try {
            // Create animation preset object
            const animationPreset = {
                id: `preset_${Date.now()}`,
                name: saveAnimationName,
                animations: activeAnimations,
                markers: animationMarkers,
                createdAt: new Date().toISOString()
            };

            // Add to saved animations
            const updatedSavedAnimations = [...savedAnimations, animationPreset];
            setSavedAnimations(updatedSavedAnimations);

            // Save to localStorage
            localStorage.setItem('savedAnimations', JSON.stringify(updatedSavedAnimations));

            // If onSaveAnimations callback is provided, call it
            if (onSaveAnimations) {
                onSaveAnimations(updatedSavedAnimations);
            }

            // Close dialog
            setSaveDialogOpen(false);
        } catch (error) {
            console.error('Error saving animations:', error);
            // Show error notification
        }
    };

    // Open load dialog
    const handleOpenLoadDialog = () => {
        setLoadDialogOpen(true);
    };

    // Load saved animation preset
    const handleLoadAnimationPreset = (preset) => {
        if (!preset) return;

        // Set active animations from preset
        if (preset.animations && preset.animations.length > 0) {
            setActiveAnimations(preset.animations);
        }

        // Set markers from preset if available
        if (preset.markers && preset.markers.length > 0) {
            setAnimationMarkers(preset.markers);
        }

        // Close dialog
        setLoadDialogOpen(false);
    };

    // Delete saved animation preset
    const handleDeleteAnimationPreset = (presetId) => {
        const updatedSavedAnimations = savedAnimations.filter(preset => preset.id !== presetId);
        setSavedAnimations(updatedSavedAnimations);
        localStorage.setItem('savedAnimations', JSON.stringify(updatedSavedAnimations));
    };

    if (!isVisible) return null;

    return (
        <MuiBox
            sx={{
                position: embedded ? 'relative' : 'fixed',
                top: embedded ? 'auto' : 0,
                left: embedded ? 'auto' : 0,
                width: '100%',
                height: '100%',
                zIndex: embedded ? 'auto' : 1000,
                backgroundColor: embedded ? 'transparent' : 'rgba(0, 0, 0, 0.85)',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: embedded ? 2 : 0,
                overflow: 'hidden',
                overscrollBehavior: 'contain',
                touchAction: 'pan-y',
            }}
        >
            {isLoading ? (
                <MuiBox sx={{ color: 'white', textAlign: 'center' }}>
                    <CircularProgress color="primary" size={60} />
                    <MuiBox mt={2}>Загрузка 3D движка...</MuiBox>
                </MuiBox>
            ) : (
                <>
                    <MuiBox sx={{ width: '100%', height: embedded ? '100%' : '70%', position: 'relative' }}>
                        {/* Canvas container */}
                        <MuiBox
                            sx={{
                                width: '100%',
                                height: '100%',
                                backgroundColor: '#1a1a1a', // Темный фон для 3D сцены
                                borderRadius: embedded ? 2 : 0,
                                overflow: 'hidden',
                                position: 'relative',
                                border: embedded ? '1px solid rgba(255, 255, 255, 0.1)' : 'none',
                                boxShadow: embedded ? 'inset 0 0 20px rgba(0, 0, 0, 0.5)' : 'none',
                                '& > div': {
                                    touchAction: 'none',
                                    overscrollBehavior: 'contain',
                                    '&:focus-visible': {
                                        outline: 'none'
                                    }
                                }
                            }}
                        >
                            <Canvas style={{ background: '#111' }}>
                                <ambientLight intensity={0.6} />
                                <directionalLight position={[5, 5, 5]} intensity={1} castShadow />
                                <directionalLight position={[-5, 5, 5]} intensity={0.5} />
                                <directionalLight position={[0, 5, -5]} intensity={0.5} />
                                <PerspectiveCamera makeDefault position={[0, 2, 10]} />
                                <Suspense fallback={null}>
                                    <XbotModel
                                        currentTime={currentTime}
                                        isPlaying={isPlaying}
                                        onTimeUpdate={handleTimeUpdate}
                                        onModelLoad={handleModelLoad}
                                        playerDuration={playerDuration}
                                        animationMarkers={animationMarkers}
                                        activeAnimations={activeAnimations}
                                        glbAnimationUrl={glbAnimationUrl}
                                    />
                                    <Grid
                                        position={[0, -1, 0]}
                                        args={[10, 10]}
                                        cellSize={1}
                                        cellThickness={1}
                                        cellColor="#555"
                                        sectionSize={3}
                                        sectionThickness={1.5}
                                        sectionColor="#888"
                                        fadeDistance={30}
                                    />
                                </Suspense>
                                <OrbitControls
                                    makeDefault
                                    enableDamping
                                    dampingFactor={0.1}
                                    rotateSpeed={0.5}
                                    enableZoom={true}
                                    zoomSpeed={0.8}
                                    enablePan={true}
                                    panSpeed={0.5}
                                />
                            </Canvas>
                        </MuiBox>
                    </MuiBox>

                    {/* Controls */}
                    <MuiBox
                        sx={{
                            width: '100%',
                            display: 'flex',
                            flexDirection: 'column',
                            alignItems: 'center',
                            mt: 2,
                            px: 2,
                            backgroundColor: embedded ? 'rgba(0, 0, 0, 0.5)' : 'transparent',
                            borderRadius: embedded ? 1 : 0,
                            py: embedded ? 1 : 0
                        }}
                    >
                        {/* Animation controls */}
                        <MuiBox sx={{ width: '100%', display: 'flex', alignItems: 'center', mb: 1 }}>
                            <IconButton
                                onClick={handlePlayPause}
                                sx={{
                                    color: 'white',
                                    mr: 1,
                                }}
                            >
                                {isPlaying ? <Pause /> : <PlayArrow />}
                            </IconButton>

                            <Typography variant="body2" sx={{ color: 'white', mr: 1, minWidth: '60px' }}>
                                {formatTime(currentTime)}
                            </Typography>

                            <MarkedSlider
                                value={currentTime}
                                min={0}
                                max={duration}
                                onChange={handleTimeChange}
                                markers={animationMarkers}
                                disabled={false}
                                onMarkerAdd={handleAddMarker}
                                onMarkerEdit={handleEditMarker}
                                onMarkerDelete={handleDeleteMarker}
                            />

                            <Typography variant="body2" sx={{ color: 'white', ml: 1 }}>
                                {formatTime(duration)}
                            </Typography>
                        </MuiBox>

                        <Typography variant="caption" color="text.secondary" sx={{ display: 'block', textAlign: 'center', mt: 1 }}>
                            {elementId ?
                                `Маркеры синхронизированы с ключевыми кадрами элемента. ${elementKeyframes.length} ключевых кадров.`